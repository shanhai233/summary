## 1 基础

### 1 基础架构 : 一条SQL查询语句是如何执行的？

```mysql
mysql> select * from T where ID=10；
```

​		大体来说，MySQL可以分为Server层和存储引擎层两部分。 

​		**Server层包括连接器、查询缓存、分析器、优化器、执行器等**，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 

​		**存储引擎层负责数据的存储和提取。**其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。 

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325093607895.png" alt="image-20220325093607895" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.5/202104/mysql-4.png" alt="SQL执行的全部过程" style="zoom: 67%;" />

**Server层按顺序执行sql的步骤为：**

1. 客户端请求  -> 

2. 连接器（验证用户身份，给予权限） ->      (连接器负责跟客户端建立连接、获取权限、维持和管理连接。)

   ```mysql
   mysql -h ip -P port -u user -p  # TCP握手验证身份
   ```

3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）->

   ```mysql
   #之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。不推荐，因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空；按需使用：你可以将参数query_cache_type设置成 DEMAND，可以用SQL_CACHE显式指定；8.0开始彻底没有这个功能了。
   mysql> select SQL_CACHE * from T where ID=10;
   ```

4. 分析器（对SQL进行**词法分析**和**语法分析**操作） -> （要怎么做）

   ```mysql
   #词法分析：MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。
   #语法分析：根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法，以及语义分析
   ```

5. 优化器（主要对执行的sql优化选择最优的执行方案方法） ->  （要做什么）

   ```mysql
   #在表里面有多个索引的时候，决定使用哪个索引
   ```

6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-> （执行语句）

   ```mysql
   #先判断一下你对这个表T有没有执行查询的权限
   #如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
   ```

7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

   ```mysql
   #数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。
   #在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 引 rows_examined r 并不是完全相同的。
   ```

**简单概括：**

- **连接器**：管理连接、权限验证；
- **查询缓存**：命中缓存则直接返回结果；
- **分析器**：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）
- **优化器**：执行计划生成、选择索引；
- **执行器**：操作引擎、返回结果；
- **存储引擎**：存储数据、提供读写接口。

### 2 日志系统：一条SQL更新语句是如何执行的？

```mysql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;  #ID=2这一行的值加1

#一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。
#接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。 然后，执行器负责具体执行，找到这一行，然后更新。
#更新流程还涉及两个重要的日志模块:redo log（重做日志）和 binlog（归档日志）
```

#### 1. 重要的日志模块： redo log

​		**WAL技术：**先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。InnoDB引擎特有的日志。

​		InnoDB的redo log是**固定大小的**，可以配置为一组4个文件，每个文件的大小是1GB，总共就可以记录4GB的操作。

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325101022330.png" alt="image-20220325101022330" style="zoom:50%;" />

​		write pos是当前记录的位置，checkpoint是当前要擦除的位置。   

​		有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe** 。 

​		用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候， 表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。 

#### 2. 重要的日志模块： binlog

​		Server层也有自己的日志，称为binlog（归档日志）。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。

这两种日志有以下三点不同：

​		1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 

​		2. **redo log**是**物理日志**，记录的是“**在某个数据页上做了什么修改**”；**binlog**是**逻辑日志**，记录的是**这个语句的原始逻辑**，比如“给ID=2这一行的c字段加1 ”。 

​		3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

执行器和InnoDB引擎在执行这个简单的update语 句时的内部流程：(浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的)

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325104105231.png" alt="image-20220325104105231" style="zoom:50%;" />

​		redo log的写入，两阶段提交：prepare和commit，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

​		redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

​		sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。 

## 2 事务

### 1. 事务隔离：为什么你改了我还看不见？

​		事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。 

​		事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

#### 隔离性与隔离级别

​		当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantomread）的问题，为了解决这些问题，就有了“隔离级别”的概念。

​		SQL标准的事务隔离级别包括：读未提交（read uncommitted）、 读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 

- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 

- 可重复读，一个事务执行过程中看到的数据总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见。 

- 串行化，是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 

  ​	Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致， 你一定要记得将MySQL的隔离级别设置为“读提交”。配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用showvariables来查看当前的值。 

#### 事务隔离的实现 

​		可重复读，在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325105749765.png" alt="image-20220325105749765" style="zoom: 50%;" />

​		尽量不要使用长事务：长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

#### 事务的启动方式

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 

2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

​        我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。 对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。 

##### 如何避免长事务对业务的影响？

这个问题，我们可以从应用开发端和数据库端来看。 

首先，从应用开发端来看： 

1. 确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。 

2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。 

3. 业务连接数据库的时候，根据业务本身的预估，通过SETMAX_EXECUTION_TIME命令， 来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例） 

其次，从数据库端来看： 

1. 监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill； 

2. Percona的pt-kill这个工具不错，推荐使用； 

3. 在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题； 

4. 如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。 

## 3 索引

### 1. 深入浅出索引

#### 索引的常见模型

​		哈希表、有序数组和搜索树

​		哈希表：一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。同一个值，链表。

​				       哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。哈希索引做区间查询的速度是很慢的。

​		有序数组：在等值查询和范围查询场景中的性能就都非常优秀，二分法，查询效率好，但更新数据的时候麻烦，只适用于静态存储引擎序数组索引

​		搜索树：二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。 

​						树高20。一次查询可能需要访问20个数据块。为了让查询过程访问尽量少的数据块，要使用“N叉”树，树第二层有很大概率在内存中

​		在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。

#### InnoDB 的索引模型

​		在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。

​		InnoDB使用了B+树索引模型，数据都是存储在B+树中的。 每一个索引在InnoDB里面对应一棵B+树。

​					因为B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

​					B+ 树非叶子节点上是不存储数据的，仅存储键值，而且数据是按照顺序排列的。而 B 树节点中不仅存储键值，也会存储数据。

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325121211007.png" alt="image-20220325121211007" style="zoom:50%;" />

​		索引类型分为主键索引和非主键索引。

​				主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。 

​				非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引 （secondary index）。

​				主键查询方式，则只需要搜索ID这棵B+树；

​				普通索引查询方式，则需要先搜索k索引树，得到ID 的值为500，再到ID索引树搜索一次。这个过程称为回表。 

#### 索引维护

​		自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOTNULL PRIMARY KEY AUTO_INCREMENT。

​		插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条 新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

​		主键长度越小，普通索引的叶子节点越小，普通索引所占的空间越小。

​		从性能和存储空间方面考量，自增主键往往是更合理的选择。 

#### 覆盖索引

​		select *fromTwhere k between 3 and 5，这个查询过程读了k索引树的3条记录，回表了两次

​		如果执行的语句是select ID fromTwhere k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面， 索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。 

#### 最左前缀原则

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

#### 索引下推


### 1  基础知识

#### 1. C++和C的关系（区别）

​		① C++是C语言的加强，在C语言的基础上增加了面向对象编程和泛型编程的支持，并且可以很好兼容C语言。

​		② C++是面向对象的编程语言，具有封装、继承、多态的特性，减少了重复代码重写的过程；C语言是面向过程的语言，根据业务逻辑从上到下编写代码。

​		③ C++增加了很多特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等

​		④ C++引入了模板的概念，实现了方便开发的模板库STL，相对于C语言更加灵活通用。

#### 2. C++编译时和C的不同

​		由于C++支持函数重载，C++和C对同一个函数经过编译器编译后的函数名是不一样的，会加上参数类型，C语言一般只包括函数名。

#### 3. 面向对象的三大特性

​		**封装**：是指把客观事物封装成类，也就是把属性和操作合成一个整体，程序可以由多个对象组成，并且可以进行访问控制。

​		**继承**：是指一个类可以继承另一个类的属性和操作，并且可以进行扩展。

​		**多态**：一个接口，多种方法，运算符重载和函数重载是**编译时多态**，派生类和虚函数实现**运行时多态**。

#### 4. C++对C的扩展

​		**(1) 检测：全局变量**检测增强、**函数**检测增强（函数参数、返回值、传参个数）、**类型**检测增强（函数和变量必须有类型，类型转换更严格）

​		**(2) 作用域**：**变量可以在使用的时候再定义**，C语言变量是在作用域开始的时定义的；引入**作用域运算符::**，命名空间**namespace、using**

​		**(3) 类型**：新增**bool类型**，**struct类型**增强（使用的时候不用再加struct，可以定义函数，增加权限设置，可以继承和多态）

​		**(4) 运算符**：**三目运算符**增强（返回的不是值是地址）

​		**(5) 关键字**：**register**增强（可以取地址，但取地址之后失效，有自己的优化方式）；**const**常量（不必**创建内存空间**，取代宏常数定义define）

​		**(6) 引用：**必须初始化；不能直接对数组进行引用；作为函数参数，常量引用通常作为函数形参，	函数可以返回静态变量的引用；本质是一个指针常量；

​		**(7) 内联函数：**取代宏函数，由**编译器**处理，直接将编译后的函数插入调用地方（宏代码片段由**预处理器**处理）必须函数体和声明结合在一起

​		**(8) 函数**：默认参数，占位参数，函数重载（若遇上默认参数可能编译器不会通过）

#### 5. C++和C的struct区别

​		(1) 使用时，C语言必须加上struct或者用typedef起别名，C++可以**直接使用**

​		(2) 定义时，C的结构体内不允许有**函数存在**，C++允许有内部成员函数，且允许该函数为虚函数。

​		(3) C的结构体对内部成员的**访问权限**只能是public，C++允许public、private、protected三种

​		(4) C++的结构体可以**继承和多态**，C不可以

#### 6. 指针和引用的区别

​		(1) 指针是一个**具体变量**，存储的是原变量的地址（虚拟地址），引用本质是一个指针，是原变量的**别名**。

​		(2) 指针可以为空NULL，引用不能为空在定义时必须**初始化**；指针在初始化后可以改变指向，引用初始化后不可以再改变引用。

​		(3) 指针可以有**多级**，引用不可以。

​		(4) **函数**用指针**传参**时，是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一变量，若在函数中改变指针的指向不影响实参，而引用可以影响实参。

##### 使用函数过程中，什么时候该使用指针、引用？

​		① 需要返回函数内局部变量时用指针，返回局部变量的引用没有意义（因为地址是随机的）。

​		② 对栈的空间大小比较敏感的时候用引用（如递归），使用引用传递不需要创建临时变量，开销要更小，但指针需要。

​		③ 类对象作为参数传递的时候要使用引用，这是标准方式。

#### 7. 关键字

##### (1) 导入C函数的关键字

```c++
#pragma  once

#ifdef __cplusplus //两个_下划线 __cplusplus和c_plusplus这两个宏有定义，说明你使用的c++的编译器。 表示这是一段cpp文件的代码
extern "C" {
#endif // !__cplusplus

#include <stdio.h>

	void show();

#ifdef __cplusplus //两个_下划线
}
#endif // !__cplusplus
```

##### (2) 避免include文件多次

```c++
//头文件 宏定义
#ifdef CONFIG_H
#define CONFIG_H
#endif
//或者
#pragma once
```

##### (3) static静态变量

​		静态变量只能在本源文件中使用。不加static的全局变量和函数具有全局可见性，其他文件可以使用

​		**作用：**定义全局静态变量和局部静态变量（作用域不一样，函数退出后局部静态变量仍然存在，但不能使用）；定义静态函数；定义类中的静态成员变量和静态成员函数（实现类对象的共享）

##### (4) const常量

​		在定义时必须初始化，之后无法修改；const形参可以接收const和非const类型的实参

​		类：const成员变量只能通过构造函数初始化列表初进行初始化；const成员函数不能调用非const成员函数，不可以改变非mutable数据的值

##### (5) volatile

​		 是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改；防止优化编译器把变量从内存装入CPU寄存器

​		使用volatille声明的变量时，系统总是重新从它所在的内存读取数据，多线程中被几个任务共享的变量需要被定义为volatile

##### (6) mutable

​		突破const的限制

##### (7) explicit

​		修饰类的构造函数，作用于单个参数的构造函数，不能发生隐式类型转换

#### 8. 深拷贝和浅拷贝

​		**浅拷贝：**只是拷贝一个指针，并没有开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针指向的资源释放了，再释放浅拷贝的指针的资源就会出现错误

​		**深拷贝：**不仅拷贝值，还开辟出一块新的空间来存放新的值

#### 9. include ""和尖括号<>的区别

​		尖括号<>的头文件时系统文件，查找的时候，先查找编译器设置的头文件路径，然后查找系统变量

​		双引号""的头文件时自定义文件，查找时，先查找当前头文件目录，然后编译器设置的头文件，然后系统变量

#### 10.宏定义和内联函数

##### (1) 内联函数inline

​		内联函数避免了函数调用的开销，由**编译器**处理，直接将编译后的函数插入调用地方，要求代码简单。

##### (2) 宏定义函数与内联函数

​		宏函数是在预处理的时候把所有的宏名用宏体来替换（字符串替换）；内联函数是在编译的时候进行代码的插入，且有返回值。

​		宏函数没有类型的检查，内联函数会进行参数类型检查

##### (3) 宏定义常量与const常量

​		define是在预处理阶段起作用，const是在编译的时候起作用

​		define只做替换，不做类型检查和计算；const有数据类型，会做类型检查

​		define只是将宏名称替换，没有分配内存空间，但在内存中会产生很多相同的备份；const会分配内存空间，而且能将复杂的表达式计算结果放入常量表

#### 11. 变量声明和定义区别

​		声明只是把变量的声明位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配内存空间

​		相同变量可以在多处声明，但只能在一处定义

#### 12. strlen和sizeof区别

​		sizeof是运算符，结果是在编译时得到；strlen是字符处理的库函数

​		sizeof参数可以是任何数据的类型或者数据；strlen的参数只能是字符指针且结尾是'\0'的字符串

​		sizeof在编译时确定，所以不能用来得到动态分配存储空间的大小

#### 13.指针

##### (1) 常量指针和指针常量

​		指针常量是一个指向常量的指针，可以修改指针指向；常量指针是一个不能改变指向的指针，可以修改变量值。

##### (2) 数组名和指针

​		两者均可以通过增减偏移量来访问数组中的数据

​		数组名不是真正意义上的指针，可以理解为常指针，不能做自增自减操作，当数组名当作形参传递给函数时，会退化为一般指针，多了自增自减操作。

##### (3) 野指针和悬空指针

​		都是指向无效内存区域的指针，访问行为会导致未定义行为

​		**野指针：**没有被初始化的指针；解决：定义指针变量及时初始化，要么置空

​		**悬空指针：**指针最初指向的内存已经被释放了；解决：free或delete后立即置空。

##### (4) 函数指针和指针函数

​		函数指针：指向函数的指针变量（函数的入口地址）；应用场景：回调（别人的库里调用我们的函数）

​		指针函数：是一个函数，返回值为指针

#### 14. 形参与实参

​		形参只有在被调用的时候才分配内存单元，在调用结束时，立即释放所分匹配的内存单元，只在函数内部有效；实参是具有确定的值，以便把值传给形参，会产生临时变量。

​		当形参和实参不是指针时，是不同的变量，他们在内存中处于不同的位置。

​		函数调用中发生的数据传送是单向的，只能把实参的值传送给形参

#### 15. string与char*的区别

​		string继承自basic_string，其实是对char* 进行了封装，包含了char* 数组，容量，长度等等属性

​		string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间，然后将原字符串拷贝过去，并加上新的内容。

#### 17. nullptr调用成员函数

​		能       原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

​		由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

#### 18. 一个类，默认会生成哪些函数

​		无参的构造函数、拷贝构造函数、赋值运算符、析构函数（非虚）



### 2  类和对象

#### 1. 类的封装

##### (1) class和struct的异同

​		**相同点：**两者都有成员变量、成员函数以及权限设置；任何可以用class完成的工作，同样可以用struct完成，struct被当成类的一种特例。

​		**不同点：**

​				struct一般用于**描述**一个数据结构的集合，class是对一个对象的封装；

​				struct默认**访问权限**是public，class的默认访问权限是private；struct是公有**继承**，class是私有继承；

​				struct不能用于**定义模板参数**，class可以用于定义模板参数。

##### (2) 类的访问权限

​		**类内：**没有访问权限之分，所有成员可以互相访问，除了静态成员函数不能访问普通成员变量。

​		**类外：**有不同的访问权限，public共有权限、private私有权限、protected保护权限（子类可以访问）

​					只有public修饰的成员才能被访问，在没有涉及继承与派生时，private和protected是同等级的，外部不允许访问

###### 	建议将成员变量设置为private

​		① 可以赋予**客户端访问数据的一致性**：只访问成员函数，不用考虑访问的是成员变量还是成员函数；

​		② 可以**划分访问控制**：只读、只写、读写

##### (3) 构造函数和析构函数

###### ① 作用

​		**构造函数：**创建对象时为对象的成员属性赋值，没有返回值；由编译器自动调用，无需手动调用。

​		**析构函数：**对象销毁前系统自动调用，执行清理工作；没有返回值，不能有参数，不能重载。

​		构造和析构必须写在public下才可以调用到

​		如果成员是const、引用或者属于某种未提供默认构造类型的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

###### ② 构造函数的种类

​		按**参数类型**：无参构造函数（默认构造函数）和 有参构造函数

​		按**类型分类**：**普通构造函数** 、 **拷贝构造函数**（对非静态成员进行浅拷贝）和 **移动构造函数**（C++11）

**拷贝构造函数：**

​		**浅拷贝：**当类中属性里有指向堆区空间的数据，析构函数做了动态内存释放的处理，会释放堆区空间两次，导致内存问题。解决方法：显示提供copy构造函数；显示操作重载=号操作，不使用编译器提供的浅copy；在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

​		**参数是必须是引用传递**，如果不是引用的话会无穷递归地调用拷贝构造函数。

**拷贝构造函数 和 移动构造函数：**

​		**相同点：**都是用一个对象的值去设置另一个对象的值

​		**不同点：**拷贝构造函数是值拷贝，需要分配新内存，只是内容进行了拷贝；移动构造函数是对象值得真实转移，源对象将丢失内容，被目标对象占有，不用分配新内存，节省拷贝时间和内存；拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用（使用右值引用&&实现（右值只能赋值和销毁））

###### ③ 构造函数的调用

**调用规则：**

​		默认情况下，编译器提供三个函数：默认构造函数，默认拷贝构造函数，默认析构函数

​		若用户定义了拷贝构造函数，编译器不提供任何默认构造函数；若用户定义了普通构造函数（非拷贝），系统不提供默认构造函数，但提供默认拷贝构造函数。

**调用方式：**

​		显示法、括号法、匿名对象（不能拷贝构造）、隐式法（=）

**拷贝构造函数的调用：**

​		① 用已经创建好的对象来初始化新的对象

​		② 以值传递的方式给函数参数传值

​		③ 以值方式返回局部对象  ( vs debug模式下调用一次拷贝构造，release、qt不调用任何构造)

###### ④ explicit关键字

​		声明为explicit的构造函数不能在隐式转换中使用

##### (4) 动态对象创建

###### ① 用malloc + free创建

​		必须确定对象地长度；返回一个void*指针，C++必须强转；必须判断返回值来确保内存分配成功；使用对象前必须初始化（不自主调用构造函数）

###### ② 用new + delete创建

​		new先分配内存，然后调用构造函数；delete先调用析构函数，然后释放内存。 运算符，堆区开辟。

​		当创建一个对象数组时，必须对数组中每个对象调用构造函数，因此必须提供一个默认的构造函数。

##### (5) 类的成员

​		两种成员变量：普通成员变量，静态成员变量

​		三种成员函数：普通成员函数、静态成员函数、虚函数

##### (6) static静态成员

​		**静态成员变量：**属于某个类，所有对象共享；**在类中声明，在类外定义**；可以直接通过类名调用

​		**静态成员函数：**为了访问静态成员变量，变量不能访问普通成员变量；普通成员变量都可以访问。（因为没有this指针）（不能声明为const，虚函数和volatile）

​		**实现单例模式：**只包含一个实例被称为单例的特殊类，保证系统中一个类只有一个实例且易于外界访问；为了防止外部对其实例化，将其构造函数设计为私有，定义一个静态构建实例方法返回静态成员变量，作为外部共享的唯一实例。



##### (7) this指针

​		当调用一个对象的非静态成员函数时，系统会把该对象的起始地址给成员函数的this指针，静态成员函数不属任何一个对象因此没有this指针，不能操作非静态成员变量。

​		**使用：**当形参和成员变量同名时，可以用this指针来区分；若返回对象本身，则可以用 return *this；

##### (8) const关键字

​		**修饰静态成员变量：static const：**在类内初始化；实现共享，但不改变。

​		**修饰成员函数：**const修饰的是this指针指向的内存区域，不能修改任何普通成员变量，但用**mutable**修饰的例外。

​		**修饰对象：**const对象不能调用普通成员函数，只能调用const的成员函数；可以访问成员变量，不能修改，除非用**mutable**修饰。

##### (9) C++ 类内可以定义引用数据成员吗？

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

#### 2. friend友元

​		**友元函数是一种特权函数，允许这个特权函数访问其他类的私有成员。**

​				(1) friend关键字只出现在声明处。

​				(2) 其他类，类成员函数，全局函数都可以声明为友元。

​				(3) 友元函数不是类的成员，不带this指针。

​				(4) 友元函数可以访问对象任意成员属性，包括私有属性。

​				(5) 友元关系是单向的，不具有传递性，不能被继承。

#### 3. 运算符重载

​		函数名字为 **operator 运算符** ，目的是为了自定义数据类型进行运算；一般一元运算符用成员函数重载，二元函数用全局函数+友元。

​				= [] () -> 只能通过成员函数进行重载

​				<< 和 >> 只能通过全局函数配合友元函数进行重载

​				++ 通过一个int参数进行前置和后置重载

​				不要重载&& 和 || 无法实现短路规则

#### 4. 继承和派生

​		一个类继承了其他类的属性和方法，父类（基类）、子类（派生类）

##### (1) 继承方式

​		三种继承方式：public、private、protected

##### (2) 构造和析构

​		子类对象在创建时会先调用父类的构造函数，然后调用子类的；析构顺序相反。

​		父类构造函数有参时，需要子类初始化列表中显示调用父类构造函数。

##### (3) 继承中同名成员

​		如果子类和父类有同名成员，子类默认访问子类的成员（本作用域，就近原则），可以用::进行同名成员区分

​		若重新定义基类的一个重载函数，子类中所有其他的版本将被自动隐藏。

##### (4) 非自动继承的函数

​		构造函数和析构函数，operator=重载操作符也不可以

##### (5) 多继承

​		同时继承多个类，但会带来二义性问题，只能显示指定调用哪个基类。

##### (6) 菱形继承和虚继承

​		**菱形继承：**两个派生类继承同一个基类又有某个类继承这两个派生类。**问题：**对基类成员访问不明确；重复继承（浪费存储空间）

​		**虚继承：**采用**虚基类**解决，但只能解决具备公共祖先的多继承所带来的二义性问题，不能解决没有公共祖先的多继承。

​		**虚基类实现：**使用vbptr 虚基类指针；指向一张 虚基类表；通过表找到偏移量；找到共有的数据

#### 5. 多态

​		派生类重写基类方法，然后基类引用指向派生类对象，调用方法时会进行动态绑定。

​		编译时多态：运算符重载和函数重载

​		运行时多态：派生类和虚函数

##### (1) 虚函数 virtual

​		C++**动态多态性**是由**虚函数**来实现的，虚函数允许子类重新定义父类的成员函数，称为**覆盖**或者**重写**。

​				虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数；

​				用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。

##### (2) 如何实现动态绑定

​		当编译器发现我们类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针vptr是指向对象的虚函数表，在多态调用的时候，根据vptr指针找到虚函数表来实现动态绑定。

​		虚函数表是在编译阶段生成，对象内存空间开辟之后，写入对象的虚函数指针，然后再调用构造函数

##### (3) 多态成立的条件

​		有继承、子类重写父类虚函数、类型兼容（父类的引用或者指针可以指向子类对象） 

##### (4) 向上类型转换

​		对象可以作为自己的类或者作为它的基类的对象来使用，能通过基类的地址来操作它。（派生类转基类）

##### (5) 抽象基类和纯虚函数

​		纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。

​		virtual void fun() = 0; 告诉编译器在虚函数表中为函数 保留一个位置，但这个位置不放地址。

​		希望基类只作为派生类的一个接口，在基类中加入至少一个纯虚函数，这个基类称为**抽象类**（不能被实例化）。

​		继承一个抽象类，必须实现所有的纯虚函数，否则派生的类也是一个抽象类。

##### (6) 虚析构函数

​		为了解决普通析构是不会调用子类的析构的，所以可能会导致释放不干净的问题，利用虚析构函数来解决这问题。

###### 纯虚析构：	

​		必须提供函数体，类内声明，类外实现；使得基类是抽象类，不能创建基类对象。

##### (7) 不能虚构造函数

​		① 存储空间角度：虚函数对应一个虚函数表，这个表是存储在对象内存空间的，如果设为虚函数，就需要到表中调用，可是对象都还没有实例化，**没有内存空间分配**，不能调用

​		② 使用角度：虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数，**构造函数**是在创建对象时自动调用的，**不能通过父类指针或者引用去调用**。

​		③ 实现角度：**虚函数在构造函数调用后才建立，因此构造函数不可能成为虚函数**

##### (8) 重写 重载 重定义

​		**重载：**同一作用域的同名函数；参数个数，参数顺序，参数类型（const也算）不同

​		**重写：**覆盖，子类重写父类的虚函数，函数返回值，函数名字，函数参数必须一致

​		**重定义：**隐藏，子类重定义父类的同名非虚函数成员

##### (9) 不能声明为虚函数的函数

​		① 非成员函数：只能重载，不能重写，编译器在编译时绑定函数

​		② 静态成员函数：要求编译时绑定，而虚函数动态绑定，生命周期也不一样

​		③ 内联成员函数：在编译时被展开

​		④ 构造函数：虚函数的运行是建立在对象的基础上

​		⑤ 友元函数：没有继承特性，没有虚函数的说法

### 3  STL标准模板库

#### 1. 什么是STL

​		标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。

​		C++ STL从广义来讲包括了三类：算法，容器和迭代器。

​				算法：包括排序，复制等常用算法，以及不同容器特定的算法。

​				容器：数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map

​				迭代器：在不暴露容器内部结构的情况下对容器的遍历

#### 2. STL 的基本组成部分

​		**广义上讲**，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。

​	  **详细的说**，STL由6部分组成：容器、算法、迭代器、仿函数、适配器、空间配制器。

  标准模板库STL主要由6大组成部分：

1. 容器 ：是一种数据结构， 数据的存放形式，以模板类的方法提供。

2. 算法：是用来操作容器中的数据的模板函数。

3. 迭代器：提供了访问容器中对象的方法。

4. 仿函数：仿函数又称之为函数对象， 其实就是重载了操作符的struct。

5. 适配器：简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。

6. 空间配制器：为STL提供空间配置的系统。（1）对象的创建与销毁；（2）内存的获取与释放。


#### 3. 容器(Container)  

​		元素非排序，容器可以用于存放各种类型的数据的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型

##### (1) 顺序容器

​		元素的插入位置同元素的值无关。包含vector、deque、list。

###### ① vector

​		**底层数据结构：数组；支持快速随机访问**

​		头文件 < vector >，动态数组，在内存连续存放

**特性：**

​		底层数据结构：数组；支持快速随机f访问

**实现：（单向开口连续的线性空间）**

​		vector与array非常类似，两者的唯一差别就是对于空间运用的灵活性

​		array使用的是**静态空间**，一旦配置了就不可以改变大小，需要用户手动扩充空间；vector使用灵活的**动态空间配置**，维护一块**连续的线性空间**，可以自动扩展空间容纳新元素，在扩充空间的过程中仍然需要经历：**重新配置空间(2倍跟平台有关)，移动数据，释放原空间**等操作。

###### ② deque

​		**头文件< deque >，双向队列，在内存连续存放**

特性：

​		底层数据结构为一个中央控制器和多个缓冲区。双向队列

​		deque是一个双端队列(double-ended queue)，也是在**堆**中保存内容的.它的保存形式如下:[堆1] --> [堆2] -->[堆3] --> ...

​		每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是**list和vector的结合品**.

**实现：（双向开口连续的线性空间）**

​		deque和vector不同：deque运行在常数时间内对头端进行元素操作；deque没有容量的概念，；deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性。

​		迭代器非常复杂，deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。

​		deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区

###### ③ list

特性：

​		**底层数据结构：双向链表；支持快速增删**

实现：

​		 头文件< list >，双向链表，在内存不连续存放，删除或插入都是常数时间，++ --都是对于指针的操作，提供双向迭代器，环形链表，只要有一个指针就能完整表现整个链表，默认采用alloc作为空间配置器。

​		list支持在头部和尾部两个方向进行push和pop，有一个node节点始终指向尾端

​		vector可能会因为空间重新配置导致迭代器失效，llist插入和接合不会造成原迭代器失效。

###### ④ slist

​		单向链表，和list主要的区别就在于，list的迭代器是双向的，slist是单向的迭代器，slist所耗用的空间更小，操作更快，只提供push_front()和pop_front()操作，且存储次序和输入次序相反，采用alloc空间配置器，

​		#include <forward_list> 在C++11出现，没有size()方法

##### (2) 关联式容器

​		元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现，包含set、multiset、map、multimap。

​		关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法。 

###### ① set/multiset

 set： 底层数据结构为红黑树，有序，不重复

multiset：底层数据结构为红黑树，有序，可重复 

unordered_set：底层数据结构为hash表，无序，不重复

unordered_multiset：底层数据结构为hash表，无序，可重复 

​		头文件< set >， set 即集合。set中不允许相同元素，multiset中允许存在相同元素。set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set不允许迭代器修改元素的值

set实现：

​		标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为。 

###### ② map/multimap

map：底层数据结构为红黑树，有序，不重复

multimap： 底层数据结构为红黑树，有序，可重复

unordered_map：底层数据结构为hash表，无序，不重复

unordered_multimap：底层数据结构为hash表，无序，可重复 

​		头文件< map >，map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

​		map同multimap的不同在于是否允许相同first值的元素。

​		一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value

map实现：

​		标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小。

​		 map是关联式容器，它们的底层容器都是**红黑树**。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。

map的特性如下

（1）map以RBTree作为底层容器；

（2）所有元素都是键+值存在；

（3）不允许键重复；

（4）所有元素是通过键进行自动排序的；

（5）map的键是不能修改的，但是其键对应的值是可以修改的。

###### ③ unordered_map和map

​		map支持键值的自动排序，底层机制是**红黑树**，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息

​		unordered_map是C++ 11新添加的容器，底层机制是**哈希表**，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大

​		从两者的底层机制和特点可以看出：**map适用于有序数据**的应用场景，**unordered_map适用于高效查询**的应用场景

##### (3) 容器适配器

​		封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue。（stack、queue这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)）

###### ① stack

特性：

​		底层数据结构：deque或者list实现，封闭头部即可；不用vector的原因应该是容量大小有限制，扩容耗时

​		头文件< stack >，把deque封装一下变为一个具有stack功能的数据结构，后进先出，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素。

​		stack这种单向开口的数据结构很容易由**双向开口的deque和list**形成；不具有遍历功能，没有迭代器。

###### ② queue 

特性：

​		底层数据结构：deque或者list实现；不用vector的原因应该是容量大小有限制，扩容耗时

​		头文件< queue >， 队列，先进先出，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素。

​		queue这种“先进先出”的数据结构很容易由双向开口的**deque和list**形成，不具有遍历功能，没有迭代器

###### ③ priority_queue

​		头文件< queue >，优先级队列，内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。

###### ④ heap

​		priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高；binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙。

​		可以使用一个array和一组heap算法来实现max heap（每个节点的值大于等于其子节点的值）和min heap（每个节点的值小于等于其子节点的值）。

​		heap算法有哪些？常见有的插入、弹出、排序和构造算法

###### ⑤ priority_queue

特性：

​		底层数据结构：vector，堆heap为处理规则来管理底层容器实现

​		优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。

​		priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器

#### 4. 迭代器

##### (1) 每种容器对应的迭代器

| 容器                                   | 迭代器         |
| -------------------------------------- | -------------- |
| vector、deque                          | 随机访问迭代器 |
| stack、queue、priority_queue           | 无             |
| list、(multi)set/map                   | 双向迭代器     |
| unordered_(multi)set/map、forward_list | 前向迭代器     |

##### (2) 迭代器什么时候会失效？

1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

##### (3) STL中迭代器的作用，有指针为何还要迭代器？

1. 迭代器的作用

   （1）用于指向顺序容器和关联容器中的元素

   （2）通过迭代器可以读取它指向的元素

   （3）通过非const迭代器还可以修改其指向的元素

2. 迭代器和指针的区别

   **迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

   **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

3. 迭代器产生的原因

   Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

##### (4) STL迭代器如何实现

1、 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。

2、 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。

3、最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly; 

#### 5. 空间配制器（Allocator）

##### (1) 请你来介绍一下 STL 的空间配置器（allocator）

​	  空间配置器用来实现内存空间分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

实现：

​		为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。

内存配置操作: 通过alloc::allocate()实现     内存释放操作: 通过alloc::deallocate()实现     对象构造操作: 通过::construct()实现     对象释放操作: 通过::destroy()实现

关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

##### (2) STL的两级空间配置器

**为什么需要二级空间配置器？**

​		我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会**在堆上造成很多外部碎片**，浪费了内存空间；

​		每次都要进行调用**malloc、free**函数等操作，使空间就会增加一些附加信息，降低了空间利用率；

​		随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。

​		于是就设置了二级空间配置器，**当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。**

**实现：**

​		关于STL中一级空间配置器和二级空间配置器的选择上，一般默认**选择的为二级空间配置器**。 如果大于128字节再转去一级配置器器。

###### 一级配置器

​	**一级空间配置器**中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：

1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数

2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常

3、如果自定义了处理函数就进行处理，完事再继续分配试试

<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.6/202104/c++-189-1.png" style="zoom: 50%;" />

###### 二级配置器

<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.6/202104/C++-189-2.png" style="zoom:50%;" />

1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。

2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：
（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。
（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。
（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。
3、内存池为空，申请内存
此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。
4、malloc没有成功
在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。



释放时调用deallocate()函数，若释放的n>128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。

STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：

1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；

2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。

###### 一级分配器

GC4.9之后就没有第一级了，只有第二级

###### 二级分配器

——default_alloc_template 剖析

有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）



allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc  2*20个块）去内存池去拿或者重新分配。不为空的话



##### (3) STL中的allocator、deallocator

1) 第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；
2) 第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；
3) 空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；
4) 空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。

#### 6. 仿函数

​	仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符。

​		仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。

#### 7. 其他

##### (1) 如何在共享内存上使用STL

1. 把STL容器放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。

   ​	当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。

2. 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？

   ​		一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。

##### (2) push_back 和 emplace_back 的区别

​		如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

##### (3) resize 和 reserve 的区别

1. 首先必须弄清楚两个概念：

   （1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。

   （2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。

2. resize和reserve区别主要有以下几点：

   （1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。

   （2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。

   （3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

   

  resize 和 reserve 既有差别，也有共同点。两个接口的**共同点**是**它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。**下面就他们的细节进行分析。

  为实现resize的语义，resize接口做了两个保证：

​    （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；

​    （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。

  reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。

##### (4) 红黑树

红黑树的特性：

- 每个节点不是红色就是黑色

- 根结点为黑色

- 如果节点为红色，其子节点必为黑

- 任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同

**红黑树概念**

  1、它是二叉排序树（继承二叉排序树特显）：

  - 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。 

  - 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。 

  - 左、右子树也分别为二叉排序树。 

  2、它满足如下几点要求： 

- 树中所有节点非红即黑。 

- 根节点必为黑节点。 

- 红节点的子节点必为黑（黑节点子节点可为黑）。 

- 从根到NULL的任何路径上黑结点数相同。 

  3、查找时间一定可以控制在O(logn)。

##### (5) hashtable哈希表

​		采用了**函数映射的思想**记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。

STL中的hashtable使用的是**开链法**解决hash冲突问题，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1566639786045.png" style="zoom:50%;" />

​		hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作

1. **什么时候扩容：**当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。

2. **扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。

3. ##### hash_map扩容发生什么？ 

   1)   hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。

   2)   向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。

### 4  C++11新特性

#### 1 C++ 11有哪些新特性？

​		 C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：

1. 语法的改进

   （1）统一的初始化方法

   （2）成员变量默认初始化

   （3）auto关键字  用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）

   （4）decltype  求表达式的类型

   （5）智能指针 shared_ptr

   （6）空指针 nullptr（原来NULL）

   （7）基于范围的for循环

   （8）右值引用和move语义  让程序员有意识减少进行深拷贝操作

2. 标准库扩充（往STL里新加进一些模板类，比较好用）

   （9）无序容器（哈希表）  用法和功能同map一模一样，区别在于哈希表的效率更高

   （10）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串

   （11）Lambda表达式

###### (1) 统一的初始化方法

​		在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化

###### (2) 成员变量默认初始化

​		构建一个类的对象不需要用构造函数初始化成员变量。

###### (3) auto关键字  

​		用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。

​		定义迭代器 i 的时候，类型书写比较冗长，只写一个 auto 即可

###### (4) decltype求表达式类型

​		 decltype 和 auto 的功能一样，都用来在编译时期进行自动类型推导。

​		因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。

###### auto、decltype和decltype(auto)的用法

**① auto**

​		让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，auto 让编译器通过**初始值**来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。

**② decltype**

​		它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析**表达式**并得到它的类型，却不进行实际的计算表达式的值。

**③ decltype(auto)**

​		decltype(auto)是C++14新增的类型指示符，可以用来声明**变量**以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。

###### (5) 智能指针 shared_ptr

​		和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。

###### (6) 空指针 nullptr（原来NULL）

​		nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。

###### C++中NULL和nullptr区别

​		算是为了与C语言进行兼容而定义的一个问题吧

​		NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。**在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0**。

​		在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。

​		那么在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。

​		以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，**另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。**

​		如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。

###### (7) 基于范围的for循环

###### (8) 右值引用和move语义  

1. 右值引用

   ​		C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用，但允许使用常量左值引用操作右值。 我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

   ​		为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。  右值引用也必须立即进行初始化操作，且只能使用右值进行初始化， 和常量左值引用不同的是，右值引用还可以对右值进行修改。

   ​		C++ 语法上是支持定义常量右值引用的，  但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

2. move语义

   ​		move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。

###### (9) 无序容器（哈希表）  

​		用法和功能同map一模一样，区别在于哈希表的效率更高。

(1) 无序容器具有以下 2 个特点：

  a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，

  b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：

| 无序容器           | 功能                                                         |
| :----------------- | :----------------------------------------------------------- |
| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |
| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |
| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |
| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |

###### (10) 正则表达式  

可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：

| 符号  | 意义                           |
| :---- | :----------------------------- |
| ^     | 匹配行的开头                   |
| $     | 匹配行的结尾                   |
| .     | 匹配任意单个字符               |
| […]   | 匹配[]中的任意一个字符         |
| (…)   | 设定分组                       |
| \     | 转义字符                       |
| \d    | 匹配数字[0-9]                  |
| \D    | \d 取反                        |
| \w    | 匹配字母[a-z]，数字，下划线    |
| \W    | \w 取反                        |
| \s    | 匹配空格                       |
| \S    | \s 取反                        |
| +     | 前面的元素重复1次或多次        |
| *     | 前面的元素重复任意次           |
| ?     | 前面的元素重复0次或1次         |
| {n}   | 前面的元素重复n次              |
| {n,}  | 前面的元素重复至少n次          |
| {n,m} | 前面的元素重复至少n次，至多m次 |
| \|    | 逻辑或                         |

###### (11) Lambda匿名函数

​		所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。

1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；

2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。

3) lambda表达式的语法定义如下：

~~~cpp
[capture] （parameters） mutable ->return-type {statement};
~~~

4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；

#### 2. 智能指针

##### (1) 智能指针的原理

​		智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源.

##### (2) 常用的智能指针及实现

**(1) shared_ptr** 

实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 

- 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

###### share_ptr 怎么知道跟它共享对象的指针释放了

  多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。

**(2) unique_ptr** 

unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

**(3) weak_ptr** 

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

###### weak_ptr 能不能知道对象计数为 0，为什么？

  不能。

  weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，**它的构造和析构不会引起计数的增加或减少**。

###### weak_ptr 如何解决 shared_ptr 的循环引用问题？

  为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

**(4) auto_ptr** 

 主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。

auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。

1)  auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；

2)  auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；

3)  auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；

4)  由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；

5)  Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；

6)  auto_ptr支持所拥有的指针类型之间的隐式类型转换。

7)  可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；

8)  T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。

##### (3) 智能指针的作用

1)  C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

2)  智能指针在C++11版本之后提供，包含在头文件\<memory>中，shared_ptr、unique_ptr、weak_ptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

3)  初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr\<int> p4 = new int(1);的写法是错误的

拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象

4)  unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

5)  智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

6)  weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少. 

##### (4) 智能指针的循环引用

​		循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。

​		应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。

###### 智能指针出现循环引用怎么解决？

弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

##### (4) 手写实现智能指针类需要实现哪些函数？

​		智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。

​		除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。

​		通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1

​		一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；

##### (6) 智能指针和指针的区别

1. 智能指针

   如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。

2. 指针

   C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。

3. 智能指针和普通指针的区别

  **智能指针和普通指针的区别**在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

##### (7) 智能指针的特点

1. C++中的智能指针有4种，分别为：**shared_ptr、unique_ptr、weak_ptr、auto_ptr**，其中auto_ptr被C++11弃用。  

2. **为什么要使用智能指针**：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。

3. 四种指针各自特性

   **（1）auto_ptr**

     auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。

   **（2）unique_ptr**

     unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。

     **实现原理：**将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过std:move把一个对象指针变成右值之后可以移动给另一个unique_ptr

   **（3）shared_ptr**

     共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。

     **实现原理：**有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。

##### (8) 智能指针有没有内存泄露的情况

  智能指针有内存泄露的情况发生。

1. 智能指针发生内存泄露的情况

   当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。

2. 智能指针的内存泄漏如何解决？ 为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

#### 3. 可变参数模板新特性

  可变参数模板(variadic template)使得编程者能够创建这样的模板函数和模板类，即可接受可变数量的参数。例如要编写一个函数，它可接受任意数量的参数，参数的类型只需是cout能显示的即可，并将参数显示为用逗号分隔的列表。

```c++
int n = 14;
double x = 2.71828;
std::string mr = "Mr.String objects!";
show_list(n, x);
show_list(x*x, '!', 7, mr); //这里的目标是定义show_list()

/*    
    运行结果：
      14, 2.71828
      7.38905， !, 7, Mr.String objects!
*/    
```

  要创建可变参数模板，需要理解几个要点：

  （1）模板参数包（parameter pack）；

  （2）函数参数包；

  （3）展开（unpack）参数包；

  （4）递归。

#### 4. 四种强转

##### reinterpret_cast

​		retinterpret_cast < type-id > (expression)

​		type-id必须是一个指针、引用、算术类型、函数指针或者成员指针，用于类型之间的强转。

##### const_cast

​		const_cast < type-id > (expression)

​		修饰类型的const/volatile属性，

​		用于常量指针（引用）被转化为非常量指针（引用）并且仍然指向原来的对象；一般用于修改指针 如 const char *p

##### static_cast

​		static_cast < type-id > (expression)

​		把expression转换为 type-id 类型，没有运行时类型检查来保证转换的安全性。

​		用于类层次结构中基类和派生类之间指针或引用的转换；基本数据类型的转换；把空指针转换为目标类型的空指针；把任何类型的表达式转换为void类型

​		注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

##### dynamic_cast

​		type-id 必须是类的指针、类的引用或者void*；如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

​		dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。

​		在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

### 5  C++模板

#### 1. 模板类是在什么时候实现的

1. 模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的

2. 模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。

#### 2. 类模板和模板类的区别

1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数
2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。

**答案解析**

1. 类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如  someclass<int,double> obj;
2. 和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。
3. 模板可以有层次，一个类模板可以作为基类，派生出派生模板类。

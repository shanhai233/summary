# 数据库

## 1. 关系型和非关系型数据库的区别

​		非关系型数据库（感觉翻译不是很准确）称为NoSQL，也就是Not Only SQL,不仅仅是SQL。非关系型数据库不需要写一些复杂的SQL语句，其内部存储方式是以key-value的形式存在可以把它想 象成电话本的形式，每个人名（key）对应电话（value）。常见的非关系型数据库主要有**Hbase、 Redis、MongoDB**等。非关系型数据库不需要经过SQL的重重解析，所以性能很高；非关系型数据库的可扩展性比较强，数据之间没有耦合性，遇见需要新加字段的需求，就直接増加一个 **key-value键值对** 即可。

​		关系型数据库以**表格**的形式存在，以**行和列**的形式存取数据，关系型数据库这一系列的行和列被称为表，无数张表组成了数据库，常见的关系型数据库有**Oracle、DB2、Microsoft SQL Server、MySQL**等。关系型数据库能够支持复杂的SQL查询，能够体现出数据之间、表之间的关联关系；关系型数据库也支持事务，便于**提交**或者**回滚**。

它们之间的劣势都是基于对方的优势来满足的。

* 关系型数据库的优点
  - 容易理解。因为它采用了**关系模型**来组织数据。
  - 可以保持数据的一致性。
  - 数据更新的开销比较小。
  - 支持复杂查询（带where子句的查询）
* 非关系型数据库的优点
  - 不需要经过SQL层的解析，读写效率高。
  - 基于键值对，数据的扩展性很好。
  - 可以支持多种类型数据的存储，如图片，文档等等。

## 2. 什么是非关系型数据库

非关系型数据库也叫NOSQL，采用键值对的形式进行存储。

它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。

适合使用非关系型数据库的场景：

* 日志系统
* 地理位置存储
* 数据量巨大
* 高可用

## 3. MySQL与MongoDB的区别，海量数据的存储 

数据库模型

MySQL：关系型

MongoDB：⾮关系型 

存储⽅式

MySQL：不同引擎有不同的存储⽅式

MongoDB：虚拟内存+持久化 

查询语句

MySQL：sql语句

MongoDB：使⽤MongoDB自己的查询⽅式 

常⻅架构特点

MySQL：单点、Master-Slave，MHA，Cluster 

MongoDB：通过副本集与分片来实现⾼可⽤ 

数据处理⽅式 

MySQL：不同引擎有不同处理特点

MongoDB：基于内存，将热数据存储在物理内存中，从⽽达到⾼速读写的⽬的 

海ᰁ数据的存储

MySQL效率相对较低，但是MongoDB不⽀持事务 

# Mysql

## 1 MySQL基础

### 1. 概念

#### (1) 主键、超键、候选键、外键

- **超键**：在关系中能唯一标识**元组的属性集**称为关系模式的超键   (`学号`，`性别`)，(`学号`，`年龄`)
- **候选键**：不含有**多余属性的超键**称为候选键。也就是在候选键中，若再删除属性，就不是键了！   学号、其他唯一标识的 
- **主键**：**用户选作元组标识的一个候选键程序主键**  ——   拿来做**唯⼀标识**的字段    
- **外键**：如果关系模式**R中属性K是其它模式的主键**，那么**k在模式R中称为外键**。
- 主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。

#### (2) 主键、外键、索引的区别 

​		主键：唯⼀标识⼀条记录，不允许重复，不允许为空                           ⽤来保存数据的完整性

​		外键：外键表示另⼀张表的主键，允许重复，可以是空值                    主要⽤于和其它表建立联系

​		索引：没有重复值，但可以有⼀个空值                                                   为了提高查询排序的速度 

### 2. 表

​		在MySQL中，有三种类型的表，一种是**永久表**，永久表就是创建以后用来长期保存数据的表；一种是**临时表**，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的，还有一种是临时创建的，SQL语句执行完成就会删除；一种是**虚表**，虚表其实就是**视图**，数据可能会来自多张表的执行结果。 

#### (1) 内存表和临时表

​				**内存表**，指的是使用Memory引擎的表，这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。

​				**临时表**，可以使用各种引擎类型。如果是使用InnoDB引擎(mysql5.7.6后默认)或MyISAM引擎的临时表，写数据的时候是写到磁盘上的。临时表也可以使用Memory引擎。 

#### (2) 临时表

##### ① 什么是临时表

​		MySQL在执行SQL语句的过程中，通常会临时创建一些**存储中间结果集的表**，临时表**只对当前连接可见**，在连接关闭时，临时表会被删除并释放所有表空间。

临时表分为两种：一种是**内存临时表**，一种是**磁盘临时表**

- **外部临时表**
  - 只对当前用户可见，当前会话结束的时候该临时表会自动关闭，它的数据和表结构都存储在内存中，可以与非临时表同名（同名后非临时表将对当前会话不可见，直到临时表被删除）。
  - **引擎类型**：只能是：memory（heap）、myisam、merge、innodb ，不支持mysql cluster(簇)，默认是MEMORY

- **内部临时表**
  - 一种特殊轻量级的临时表，用来**进行性能优化**。这种临时表会被MySQL自动创建并用来存储某些操作的中间结果。这些操作可能包括在优化阶段或者执行阶段。这种内部表对用户来说是不可见的，但是通过EXPLAIN或者SHOW STATUS可以查看MYSQL是否使用了内部临时表用来帮助完成某个操作。内部临时表在SQL语句的优化过程中扮演着非常重要的角色， **MySQL中的很多操作都要依赖于内部临时表来进行优化**。但是使用内部临时表需要创建表以及中间数据的存取代价，所以用户在写SQL语句的时候应该尽量的去避免使用临时表。
  - 内部临时表有两种类型：
    - **一种是HEAP临时表**，这种临时表的所有数据都会存在内存中，对于这种表的操作不需要IO操作，内存中表引擎为 **heap(Memory引擎)**。
    - **另一种是OnDisk临时表**，顾名思义，这种临时表会将数据存储在磁盘上。OnDisk临时表用来处理中间结果比较大的操作。如果HEAP临时表存储的数据大于MAX_HEAP_TABLE_SIZE，HEAP临时表将会被自动转换成OnDisk临时表。OnDisk临时表在5.7中可以通过INTERNAL_TMP_DISK_STORAGE_ENGINE系统变量**选择使用MyISAM引擎或者InnoDB引擎**。

##### ② MySQL产生临时表的

**MySQL会在下面这几种情况产生内存临时表：**

- 使用**UNION查询**。
  - UNION有两种，一种是UNION，一种是UNION ALL，它们都用于联合查询；区别是使用UNION会去掉两个表中的重复数据，相当于对结果集做了一下去重(distinct)。使用UNION ALL,则不会排重，返回所有的行。使用UNION查询会产生临时表。
- 使用**TEMPTABLE 算法**或者是UNION查询中的视图。
  - TEMPTABLE算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要MySQL要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。
- **ORDER BY和GROUP BY的子句不一样**。
- **DISTINCT**查询并且加上**ORDER BY**；
- SQL中用到**SQL_SMALL_RESULT**选项；
  - 如果查询结果比较小的时候，可以加上SQL_SMALL_RESULT来优化，产生临时表
- **FROM**中的**子查询**；
- 子查询或者semi-join时创建的表；
- EXPLAIN查看执行计划结果的Extra列中，如果使用**Using Temporary**就表示会用到临时表。

**在以下几种情况下，会创建磁盘临时表：**

- 数据表中包含BLOB/TEXT列；
- 在 GROUP BY 或者 DSTINCT 的列中有超过 512字符 的字符类型列（或者超过 512字节的 二进制类型列，在5.6.15之前只管是否超过512字节）；
- 在SELECT、UNION、UNION ALL查询中，存在最大长度超过512的列（对于字符串类型是512个字符，对于二进制类型则是512字节）；
- 执行SHOW COLUMNS/FIELDS、DESCRIBE等SQL命令，因为它们的执行结果用到了BLOB列类型。

#### (3) 视图和游标

- 视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能。
  - 视图只包含**使用时动态检索数据的查询**；不包含任何列或数据。
  - 使用视图**可以简化复杂的 sql 操作**，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。
  - **视图不能被索引，也不能有关联的触发器或默认值**，如果视图本身内有order by 则对视图再次order by将被覆盖。
  - 对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；
  - 视图主要用于简化检索，保护数据，并不用于更新，而且**大部分视图都不可以更新**。
- 游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
  - 游标为 逐条读取 结果集中的数据，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。

### 3. 数据类型

#### (1) varchar和char的区別

​		**char**：表示的是**定长**的字符串，当你输入小于指定的数目，比如你指定的数目是**char(6)**，当你输入小于6个字符的时候，char会在你最后一个字符后面补空值。当你输入超过指定允许最大长度后，MySQL会报错；使用char存储定长的数据非常方便、char检索效率高，无论你存储的数据是否到了 10个字节，都要去占用10字节的空间

​		**varchar** : varchar指的是长度为n 个字节的**可变长度**，并且是**非Unicode** 的字符数据。n 的值是介于1 - 8000之间的数值。存储大小为实际大小；使用varchar可以存储变长的数据，但存储效率没有char高。 （Unicode是一种字符编码方案，它为每种语言中的每个字符都设定了统一唯一的二进制编码，以实现跨语言、跨平台进行文本转换、处理的要求）

##### 区别

- char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。
- char的存取速度还是要比varchar要快得多
- char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。
- varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。

### 4. 命令

#### (1)  JOIN的连接的方式

​		连接的方式：**外连接、内连接、交叉连接**、**全连接**（mysql不支持）

​		**外连接** (OUTER JOIN)：外连接分为三种，分别是左外连接、右外连接、全外连接

​				**左外连接**：(LEFT OUTER JOIN或LEFT JOIN) 又称为左连接，这种连接方式会显示左表不符合条件的数据行，右边不符合条件的数据 行直接显示NULL

​				**右外连接**：(RIGHT  OUTER  JOIN  或  RIGHT  JOIN) 也被称为右连接，会显示右表不符合条件的数据行，左表不符合条件的数据行直接显示NULL

​				**MySQL暂不支持全外连接**(FULL  OUTER  JOIN  或 FULL JOIN)

​		**内连接** (INNER JOIN)：结合两个表中相同的字段，返回关联字段相符的记录，不符合条件的记录不显示。

​		**交叉连接** (Cross join)，就是笛卡尔积在SQL中的实现，SQL中使用关键字**CROSS JOIN**来表示交叉连接，在交叉连接中，随便增加一个表的字段，都会对结果造成很大的影响。

```mysql
SELECT * FROM t_Class a CROSS JOIN t_Student b WHERE a.classid=b.classid 
```

​				或者不用CROSS JOIN,直接用FROM也能表示交叉连接的效果

```mysql
SELECT * FROM t_Class a ,t_Student b WHERE a.classid=b.classid
```

​				如果表中字段比较多，不适宜用交叉连接，交叉连接的效率比较差。

​		**全连接**：全连接也就是**fun join**，**MySQL中不支持全连接**，但是可以使用其他连接查询来模拟全连接，可以使用**UNION**和**UNION ALL**进行模拟。例如

```mysql
(select columl,colum2...columN from tableA ) union (select columl,colum2...columN from tableB )
```

​				使用UNION和UNION ALL的注意事项：通过union连接的SQL分别单独取出的列数必须相同；使用union时，多个相等的行将会被合并，由于合并比较耗时，一般不直接使用union进行合并，而是通常采用union all进行合并

##### 区别：

​		内连接：只有两个元素表相匹配的才能在结果集中显示。

​		外连接： 

​				左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
​				右外连接：右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。

​		全外连接：连接的表中不匹配的数据全部会显示出来。

​		交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。

#### (2) Drop、Delete与Truncate

​		Drop、Delete、Truncate都表示删除，但是三者有一些差别：

- **Delete**
  - Delete**删除表中数据**，可以加where字句。
  - 执行delete之后，将该行的删除操作作为事务记录在日志中保存以便**进行回滚操作**来执行删除或者撤销删除，会触发这个表上所有的delete触发器。
  - DELETE操作不会减少表或索引所占用的空间
  - DELETE可以是table和view
- **Truncate**
  - Truncate删除**表中数据**，再插入时自增长id又从1开始 ;  表结构及其列、约束、索引等保持不变
  - 删除表中的所有数据，**这个操作不能回滚**，也不会触发这个表上的触发器，TRUNCATE比delete更**快**。
  - 当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，TRUNCATE比delete占用的空间更小。
  - TRUNCATE 只能对TABLE
  - truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同，
    - 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句
- **Drop**
  - Drop直接删掉表（结构和数据）表结构及其列、约束、索引等保持不变;
  - 删除表，所有的数据行，索引和权限也会被删除，触发器也不会被触发，不能回滚；依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid
  - drop语句将表所占用的空间全释放掉

**使用情景**

1. drop > truncate > delete，因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。
2. 如果与事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。

#### (4) now() 和 current_date()

​		NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
​		CURRENT_DATE（）仅显示当前年份，月份和日期。

#### (5) 语句的执行顺序

我们在编写一个查询语句的时，执行顺序是什么样的

```mysql
1	SELECT DISTINCT
2		< select_list >
3	FROM
4		< left_table > < join_type >
5	JOIN < right_table > ON < join_condition > 
6	WHERE
7		< where_condition >
8	GROUP BY
9		<  group_by_list >
10	HAVING
11		<  having_condition >
12	ORDER BY
13		<  order_by_condition >
14	LIMIT  < limit_number >
```

**(1) FROM连接**

​		对SELECT语句执行查询时，对**FROM**关键字两边的表执行连接，会形成**笛卡尔积**，这时候会产生一个**虚表VTl(virtual table)**

​				**笛卡尔积**： 现在我们有两个集合A = {0,1}，B = {2,3,4} ，那么，集合A*B得到的结果就是A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)}; 
​									B * A = {(2,0)、{2,1}x {3,0}. {3,1}. {4,0}. (4,1)}; 上面A * B和B * A的结果就可以称为两个集合相乘的 **笛卡尔积**

**(2) ON过滤**

​		对FROM连接的结果进行ON筛选，创建VT2,把符合记录的条件存在VT2中。 

**(3) JOIN连接**

​		如果是**OUTER JOIN(left join、right join)**，那么这一步就将添加外部行，如果是left join就把ON过滤条件的左表添加进来（求两个表的交集外加左表剩下的数据），如果是right join ,就把右表添加进来，从而生成新的虚拟表 VT3。

**(4) WHERE过滤**

​		执行WHERE过滤器，对上一步生产的虚拟表引用WHERE筛选，生成虚拟表VT4。 

​		**WHERE和ON的区别**：如果有外部列，ON针对过滤的是关联表，主表(保留表)会返回所有的列；如果没有添加外部列，两者的效果是一样的。

​		**应用：**对主表的过滤应该使用WHERE；对于关联表，先条件查询后连接则用0N，先连接后条件查询则用WHERE。

**(5) GROUP BY**

​		根据group by字句中的列，会对VT4中的记录进行分组操作，产生虚拟机表VT5。如果应用了group by,那么后面的所有步骤都只能得到的VT5的列或者是聚合函数(count、sum、avg等)。

**(6) HAVING**

​		紧跟着GROUP BY字句后面的是HAVING,使用HAVING过滤，会把符合条件的放在VT6

**(7) SELECT**

​		执行SELECT语句，将VT6中的结果按照SELECT进行刷选，生成VT7 

**(8) DISTINCT**

​		对TV7生成的记录进行去重操作，生成VT8。事实上如果应用了 group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。

**(9) ORDER BY**

​		应用order by子句。按照order_by_condition排序VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。

### 5. 分库和分表

​		**分库与分表的目的**在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。

​		**通过分表**，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的**缓解表锁**的问题。

​		**库内分表**，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。

**分库与分表带来的分布式困境与应对之策**
		数据迁移与扩容问题----一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。
		分页与排序问题----需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。

##### 分表策略

**分表策略**可以归纳为垂直拆分和水平拆分：

​		**水平拆分**：取模分表就属于随机分表，而时间维度分表则属于连续分表。（按用户拆分）

​							对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。

​							**解决问题：**单表中数据量增长出现的压力

​							**不解决问题：**表与表之间的io争夺

​		**垂直拆分**：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。（按关键字拆分）

​							**解决问题：**表与表之间的io竞争

​							**不解决问题：**单表中数据量增长出现的压力

### 6. 数据库三大范式

**第一范式**

​		在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。

​		如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。

​			简而言之，**第一范式就是无重复的列**。

**第二范式**

​		第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。

​		为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 第二范式（2NF）要求实体的属性完全依赖于主关键字。

​		所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。

​		简而言之，**第二范式就是非主属性非部分依赖于主关键字**。

**第三范式**

​		满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。

​		例如，**存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。**

​		简而言之，第三范式就是属性不依赖于其它非主属性。

#### 数据库三大范式精要总结

（1）简单归纳：

　　第一范式（1NF）：字段不可分；
　　第二范式（2NF）：有主键，非主键字段依赖主键；
　　第三范式（3NF）：非主键字段不能相互依赖。

（2）解释：

　　1NF：原子性。 字段不可再分,否则就不是关系数据库;；
　　2NF：唯一性 。一个表只说明一个事物；
　　3NF：每列都与主键有直接关系，不存在传递依赖。

### 7. explain

MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来**分析查询语句**，EXPLAIN语句的基本语法如下：

```
EXPLAIN [EXTENDED] SELECT select_options
```

使用EXTENED关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：

- id：SELECT识别符。这是SELECT的查询序列号。
- select_type：表示SELECT语句的类型。
- table：表示查询的表。
- type：表示表的连接类型。
- possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。
- key：是MySQL实际选用的索引。
- key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。
- ref：给出了关联关系中另一个数据表里的数据列名。
- rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。
- Extra：提供了与关联操作有关的信息。

**扩展阅读**

DESCRIBE语句的使用方法与EXPLAIN语句是一样的，分析结果也是一样的，并且可以缩写成DESC。。DESCRIBE语句的语法形式如下：

```
DESCRIBE SELECT select_options
```

####  explain关注什么

重点要关注如下几列：

| 列名    | 备注                                                         |
| :------ | :----------------------------------------------------------- |
| type    | 本次查询表联接类型，从这里可以看到本次查询大概的效率。       |
| key     | 最终选择的索引，如果没有索引的话，本次查询效率通常很差。     |
| key_len | 本次查询用于结果过滤的索引实际长度。                         |
| rows    | 预计需要扫描的记录数，预计需要扫描的记录数越小越好。         |
| Extra   | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。 |

其中，type包含以下几种结果，从上之下依次是最差到最好：

| 类型            | 备注                                                         |
| :-------------- | :----------------------------------------------------------- |
| ALL             | 执行full table scan，这是最差的一种方式。                    |
| index           | 执行full index scan，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免回表，比ALL略好，因为索引文件通常比全部数据要来的小。 |
| range           | 利用索引进行范围查询，比index略好。                          |
| index_subquery  | 子查询中可以用到索引。                                       |
| unique_subquery | 子查询中可以用到唯一索引，效率比 index_subquery 更高些。     |
| index_merge     | 可以利用index merge特性用到多个索引，提高查询效率。          |
| ref_or_null     | 表连接类型是ref，但进行扫描的索引列中可能包含NULL值。        |
| fulltext        | 全文检索。                                                   |
| ref             | 基于索引的等值查询，或者表间等值连接。                       |
| eq_ref          | 表连接时基于主键或非NULL的唯一索引完成扫描，比ref略好。      |
| const           | 基于主键或唯一索引唯一值查询，最多返回一条结果，比eq_ref略好。 |
| system          | 查询对象表只有一行数据，这是最好的情况。                     |

另外，Extra列需要注意以下的几种情况：关键字备注Using filesort将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，需要添加合适的索引。Using temporary需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行GROUP BY时，或者ORDER BY里的列不都在索引里，需要添加合适的索引。Using index表示MySQL使用覆盖索引避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和type中的index类型混淆。Using where通常是进行了全表/全索引扫描后再用WHERE子句完成结果过滤，需要添加合适的索引。Impossible WHERE对Where子句判断的结果总是false而不能选择任何数据，例如where 1=0，无需过多关注。Select tables optimized away使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如MIN()\MAX()，这种也是比较好的结果之一。

## 2 基础架构

**一条SQL查询语句是如何执行的？**

```mysql
mysql> select * from T where ID=10；
```

### 1. MYSQL内部构造

​		**MySQL可以分为Server层和存储引擎层两部分。** 

​		**Server层包括连接器、查询缓存、分析器、优化器、执行器等**，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 

​		**存储引擎层负责数据的存储和提取。**其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。 

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325093607895.png" alt="image-20220325093607895" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.5/202104/mysql-4.png" alt="SQL执行的全部过程" style="zoom: 67%;" />

**Server层按顺序执行sql的步骤为：**

1. 客户端请求  -> 

2. 连接器（验证用户身份，给予权限） ->      (连接器负责跟客户端建立连接、获取权限、维持和管理连接。)

   ```mysql
   mysql -h ip -P port -u user -p  # TCP握手验证身份
   ```

3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）->

   ```mysql
   #之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。不推荐，因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空；按需使用：你可以将参数query_cache_type设置成 DEMAND，可以用SQL_CACHE显式指定；8.0开始彻底没有这个功能了。
   mysql> select SQL_CACHE * from T where ID=10;
   ```

4. 分析器（对SQL进行**词法分析**和**语法分析**操作） -> （要怎么做）

   ```mysql
   #词法分析：MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。
   #语法分析：根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法，以及语义分析
   ```

5. 优化器（主要对执行的sql优化选择最优的执行方案方法） ->  （要做什么）

   ```mysql
   #在表里面有多个索引的时候，决定使用哪个索引
   ```

6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-> （执行语句）

   ```mysql
   #先判断一下你对这个表T有没有执行查询的权限
   #如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
   ```

7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

   ```mysql
   #数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。
   #在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 引 rows_examined r 并不是完全相同的。
   ```

**简单概括：**

- **连接器**：管理连接、权限验证；
- **查询缓存**：命中缓存则直接返回结果；
- **分析器**：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）
- **优化器**：执行计划生成、选择索引；
- **执行器**：操作引擎、返回结果；
- **存储引擎**：存储数据、提供读写接口。



### 2. 日志系统

#### 一条SQL更新语句是如何执行的？

```mysql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;  #ID=2这一行的值加1

#一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。
#接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。 然后，执行器负责具体执行，找到这一行，然后更新。
#更新流程还涉及两个重要的日志模块:redo log（重做日志）和 binlog（归档日志）
```

#### 1. 重要的日志模块： redo log

​		**WAL技术：**先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。InnoDB引擎特有的日志。

​		InnoDB的redo log是**固定大小的**，可以配置为一组4个文件，每个文件的大小是1GB，总共就可以记录4GB的操作。

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325101022330.png" alt="image-20220325101022330" style="zoom:50%;" />

​		write pos是当前记录的位置，checkpoint是当前要擦除的位置。   

​		有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe** 。 

​		用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候， 表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。 

#### 2. 重要的日志模块： binlog

​		Server层也有自己的日志，称为binlog（归档日志）。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。

**这两种日志有以下三点不同：**

​		1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 

​		2. **redo log**是**物理日志**，记录的是“**在某个数据页上做了什么修改**”；**binlog**是**逻辑日志**，记录的是**这个语句的原始逻辑**，比如“给ID=2这一行的c字段加1 ”。 

​		3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

执行器和InnoDB引擎在执行这个简单的update语 句时的内部流程：(浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的)

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220325104105231.png" alt="image-20220325104105231" style="zoom: 67%;" />

​		redo log的写入，两阶段提交：prepare和commit，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

​		redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

​		sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。 

#### 3. redo log、undo log、binlog

**binlog（Binary Log）：**

​		二进制日志文件就是常说的binlog。二进制日志记录了MySQL所有修改数据库的操作，然后以二进制的形式记录在日志文件中，其中还包括每条语句所执行的时间和所消耗的资源，以及相关的事务信息。

​		默认情况下，二进制日志功能是开启的，启动时可以重新配置--log-bin[=file_name]选项，修改二进制日志存放的目录和文件名称。

**redo log：**

​		重做日志用来实现事务的持久性，即事务ACID中的D。它由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），它是持久的。

​		InnoDB是事务的存储引擎，它通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。这里的日志是指重做日志，在InnoDB存储引擎中，由两部分组成，即redo log和undo log。

​		**redo log用来保证事务的持久性，undo log用来帮助事务回滚及MVCC的功能。**redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log是需要进行随机读写的。

**undo log：**

​		重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。

​		redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），undo段位于共享表空间内。

### 3. MySQL存储引擎

#### (1) MySQL常见存储引擎

MySQL常见的存储引擎，可以使用

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220324172109129.png" alt="image-20220324172109129" style="zoom: 50%;" />



可以看到，InnoDB是MySQL默认支持的存储引擎，支持事务、行级锁定和外键。 

#### (2) MylSAM

​		在5.1版本之前，MylSAM是MySQL的默认存储引擎，**MylSAM并发性比较差**，使用的场景比较少。

**主要特点：**

- 不支持事务操作，ACID的特性也就不存在了，这一设计是为了性能和效率考虑的。
- 不支持外键操作，如果强行增加外键，MySQL不会报错，只不过外键不起作用。
- MylSAM默认的锁粒度是表级锁，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。
- MylSAM会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是.frm（存储表定义）、.MYD（MYData，存储数据）、MYI（MyIndex,存储索引）。这里需要特别注意的是MylSAM只缓存索引文件，并不缓存数据文件。
- MylSAM支持的索引类型有全局索引（Full-Text）、B-Tree索引、R-Tree索引
  - Full-Text索引：它的出现是为了解决针对文本的模糊查询效率较低的问题。
  - B-Tree索弓I:所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点
  -  R-Tree索引：它的存储方式和B-Tree索引有一些区别，主要设计用于存储空间和多维数据的字段做索引，自前的MySQL版本仅支持geometry类型的字段作索弓I，相对于BTREE, RTREE的优势在于范围查找。
- 数据库所在主机如果宕机，MylSAM的数据文件容易损坏，而且难以恢复。
- 增删改查性能方面：SELECT性能较高，适用于查询较多的情况
- 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
- 提供了大量的特性，包括压缩表、空间数据索引等。

#### (3) InnoDB

​		自从MySQL 5.1之后，默认的存储引擎变成了 InnoDB存储引擎，相对于MylSAM, InnoDB存储引擎有了较大的改变。

**主要特点：**

- 默认的事务型存储引擎，支持事务操作，具有事务ACID隔离特性，默认的隔离级别是可重复读Crepetable-read）、通过MVCC （并发版本控制）来实现的。能够解决脏读和不可重复读的问题。
- 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
- InnoDB支持外键操作。
- InnoDB默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。
- 和MylSAM -样的是，InnoDB存储引擎也有.frm文件存储表结构定义，但是不同的是，InnoDB的表数据与索引数据是存储在一起的，都位于B+数的叶子节点上，而MylSAM的表数据和索引数据是分开的。
- InnoDB有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。
- InnoDB和MylSAM支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。
- 增删改查性能方面，如果执行大量的增删改操作，推荐使用InnoDB存储引擎，它在删除操作时是对行删除，不会重建表。
- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
- 支持真正的在线热备份。其它存储引擎不支持，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

##### ① InnoDB与MyISAM的区别

- **锁粒度：**
  - 由于锁粒度不同，InnoDB比MylSAM支持更高的并发；
  - InnoDB的锁粒度为行锁、MylSAM的锁粒度为表锁、行锁，所以锁的开销更大，但是能解决脏读 和不可重复读的问题，相对来说也更容易发生死锁
- **可恢复性：**
  - 由于InnoDB是有事务日志的，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而MylSAM则没有事务日志。
  - InnoDB 是事务型的，可以使用 `Commit` 和 `Rollback` 语句；MylSAM不是
- **查询性能：**
  - MylSAM要优于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MylSAM可以直接定位到数据所在的内存地址，可以直接找到数据。
- **表结构文件：**
  - MylSAM的表结构文件包括：.frm（表结构定义），.MYI (索引) ，.MYD（数据）；而InnoDB的表数据文件为:.ibd和.frm（表结构定义）
- **外键：**
  - InnoDB 支持外键；MYISAM不支持
- **在线热备份：**
  - InnoDB 支持在线热备份；MYISAM不支持
- **崩溃恢复：**
  - MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- **总行数：**
  - MyISAM存储表的总行数；InnoDB不存储总行数；
- **索引：**
  - MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据
- **适用场景：**
  - MyISAM适合： 插入不频繁，**查询非常频繁**，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。
  - InnoDB适合： 可靠性要求比较高，或者要求事务； **表更新和查询都相当的频繁**， 大量的INSERT或UPDATE

##### ② MyISAM和InnoDB实现B树索引方式的区别

- **MyISAM**，**B+Tree叶节点**的data域存放的是**数据记录的地址**，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“**非聚簇索引**”

- **InnoDB**，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的**节点data域**保存了完整的**数据记录**，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“**聚簇索引**”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。

  在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

##### ③ Innodb为什么要用自增id作为主键

​		如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。

​		如果使用非自增主键（如果身份证号或学号等），由于每次插入**主键的值近似于随机**，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了**大量的碎片**，得到了**不够紧凑的索引结构**，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。

##### ④ InnoDB 是如何存储数据的？

​		**InnoDB 的数据是按「数据页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。I/O 操作的最小单位是页，**InnoDB 数据页的默认大小是 16KB**，一次最少从磁盘中读16K 内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

<img src="https://img-blog.csdnimg.cn/img_convert/243b1466779a9e107ae3ef0155604a17.png" alt="图片" style="zoom:33%;" />

<img src="https://img-blog.csdnimg.cn/img_convert/fabd6dadd61a0aa342d7107213955a72.png" alt="图片" style="zoom: 50%;" />

​		在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，**采用链表的结构**是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。

<img src="https://img-blog.csdnimg.cn/img_convert/557d17e05ce90f18591c2305871af665.png" alt="图片" style="zoom: 67%;" />

​		数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。

​		**数据页中的记录按照「主键」顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是**检索效率不高**，最差的情况下需要遍历链表上的所有节点才能完成检索。因此，数据页中有一个**页目录**，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。

​		**那 InnoDB 是如何给记录创建页目录的呢？**

<img src="https://img-blog.csdnimg.cn/img_convert/261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom: 67%;" />

**页目录创建的过程如下：**

1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），**每个槽相当于指针指向了不同组的最后一个记录**。

从图可以看到，**页目录就是由多个槽组成的，槽相当于分组记录的索引**。然后，因为记录是按照「主键值」从小到大排序的，所以**我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录**，无需从最小记录开始遍历整个页中的记录链表。

##### ③ B+ 树如何进行查询

​		上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。

​		InnoDB 里的 B+ 树中的**每个节点都是一个数据页**（页目录的索引）

<img src="https://img-blog.csdnimg.cn/img_convert/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片" style="zoom: 80%;" />

 **B+ 树的特点：**

- 只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；
- 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；

**我们再看看 B+ 树如何实现快速查找主键为 6 的记录**

- 从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；
- 在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；
- 接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。

#### (4) MEMORY存储引擎

​		**MEMORY存储引擎：**memory是MySQL中一类特殊的存储引擎，它使用存储在内容中的内容来创建表，而且数据全部放在内存中。每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为**frm类型**。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。

## 3 MySQL索引

### 1. MySQL索引概述

​		索引是一个单独的、存储在磁盘上的数据库结构，**包含着对数据表里所有记录的引用指针**。

​		索引是存储在一张表中特定列上的**数据结构**，索引是在列上创建的。并且，索引是一种数据结构。 

​		使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。

​		索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。**MyISAM和InnoDB存储引擎只支持BTREE索引**；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。

#### 优点

1. 通过创建唯一索引，可以保证数据库表中每一行**数据的唯一性**。
2. 可以大大**加快数据的查询速度**，这也是创建索引的主要原因。
3. 在实现数据的参考完整性方面，**可以加速表和表之间的连接**。
4. 在使用分组和排序子句进行数据查询时，也可以显著**减少查询中分组和排序的时间**。

#### 缺点

1. 创建索引和维护索引要**耗费时间**，并且随着数据量的增加所耗费的时间也会增加。
2. 索引需要占磁盘空间，除数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就**降低了数据的维护速度**。

#### 为什么使用索引

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 帮助服务器避免排序和临时表。
- 将随机IO变为顺序IO。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

#### 索引如何提高查询速度的

​		将无序的数据变成相对有序的数据（就像查有目的一样）

### 2. MySQL常见索引类型

- **全局索引(FULLTEXT)**
  - 全局索引，目前只有MylSAM引擎支持全局索弓I，它的出现是为了解决针对文本的模糊查询效率较低的问题。
  - 可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、ARCHAR ，TEXT 列上可以创建全文索引。
- **哈希索引(HASH)**：
  - 哈希索引是MySQL中用到的唯一key-value键值对的数据结构，很适合作为索引。
  - HASH索引具有一次定位的好处，不需要像树那样逐个节点查找，但这种查找适合应用于 查找单个键的情况，对于范围查找HASH索引的性能就会很低。
  - 但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
- **B-Tree索引**：
  - B就是Balance的意思，BTree是一种平衡树，它有很多变种，最常见的就是B+ Tree,它被MySQL广泛使用。
  - BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf
- **R-Tree索引**：
  - R-Tree在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MylSAM、BDb、InnoDb. NDb、Archive几种，相对于B-Tree来说，R-Tree的优势在于范围查找。

#### MySQL索引主要使用的两种数据结构是什么？

- **哈希索引**，对于哈希索引来说，底层的数据结构肯定是哈希表，因此**在绝大多数需求为单条记录查询**的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引

- **BTree索引**，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。

  但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

#### MySQL的Hash索引和B树索引有什么区别？

hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。它们有以下的不同：

- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
- hash索引不支持使用索引进行排序，原理同上。
- hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测。
- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。

#### MySQL中有哪些索引

- **普通索引**：仅加速查询
- **唯一索引**：加速查询 + 列值唯一（可以有null）
- **主键索引**：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- **组合索引**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- **全文索引**：对文本的内容进行分词，进行搜索
- **索引合并**：使用多个单列索引组合搜索
- **覆盖索引**：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖

- **聚簇索引**：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。
  - 使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)

#### (1) 覆盖索引

​		如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”。

​		我们知道在InnoDB存储引 擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就 会比较慢。

​		覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

#### (2) 聚合索引和非聚合索引 

##### ① 聚合索引

​		我们把这种**正文内容本身就是一种按照一定规则排列的目录称为"聚集索引"**

​		聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。

​		辅助索引（二级索引）是根据**索引键**创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该**索引键值指向的主键**。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。

- 聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；
- 二级索引的叶子节点存放的是主键值，而不是实际数据。

##### ② 非聚合索引 （二级索引）

​		我们把**这种目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"。** 

##### ③ 聚集索引与非聚集索引的区别

​		非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。

​		聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致**。它们区别就在于叶子节点存放的是什么数据

​		 聚集索引（Innodb）的叶节点就是数据节点，而非聚集索引(MyisAM)的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。

##### ④ InnoDB 在创建聚簇索引

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；

一张表只能有一个聚簇索引，**那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引）**，它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。

二级索引的 B+ 树如下图，数据部分为主键值：

<img src="https://img-blog.csdnimg.cn/img_convert/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片" style="zoom:67%;" />

​		如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。

### 3. MySQL索引用B+树

<img src="https://img-blog.csdnimg.cn/img_convert/b6678c667053a356f46fc5691d2f5878.png" alt="图片" style="zoom:67%;" />

​		**主要原因**：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

#### (1) MySQL索引用B+的原因

##### 为什么用B+树不用B树

- **查询磁盘 I/O次数少：**
  - B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」(层数（树的高度）尽量的少)，查询底层节点的磁盘 I/O次数会更少。
- **插入、删除的效率高：**
  - B+ 树有大量的冗余节点(非叶子节点)，冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- **有利于范围查询：**
  - B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

**增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？**

​		不可以。因为这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找，

##### 为什么用B+树不用hash表

- **内存角度：**
  - 利用Hash需要把数据全部**加载到内存中**，如果数据量大，是一件很**消耗内存**的事，而采用B+树，是基于**按照节点分段加载，由此减少内存消耗**。
- **业务场景角度：**
  - **对于唯一查找**Hash确实更快，**但数据库中经常查询多条数据**，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。  
- **查询效率：**
  - b+树的**非叶子节点不保存数据**，**只保存子树的临界值**（最大或者最小），所以同样大小的节点，**b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**。
  - B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。

#### (2) 文件和数据库索引使用B+树的原因

​		文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。

- **方便扫库**：
  - B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。
  - B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。
- **查找效率稳定：**
  - B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。
  - 由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
- **磁盘读写代价低：**
  - B+tree的磁盘读写代价更低：B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；

#### (3) B+树的特点

- 所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;
- 不可能在非叶子结点命中;
- 非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;

### 4. 创建数据库索引

#### (1) 适合创建索引的情况

1. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
2. 在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。
3. 在最频繁使用的、用以缩小查询范围的字段，需要排序的字段上建立索引。
4. **唯一、不为空、经常被查询的字段 的字段适合建索引**

#### (2) 不适合创建索引的情况

1. **频繁更新的字段**不适合建立索引；
2. **where条件中用不到的字段**不适合建立索引；
3. **数据比较少的表/列**不需要建索引；
4. **数据重复且分布比较均匀的的字段**不适合建索引，例如性别、真假值；
5. **参与列计算的列**不适合建索引。
6. 对于**一些特殊的数据类型**，不宜建立索引，比如文本字段（text）等。

#### (3) 创建索引时注意事项

- **非空字段**
  - 应该指定列为NOT NULL，除非你想存储NULL。
  - 在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。
  - 你应该用0、一个特殊的值或者一个空串代替空值；
  - 将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描
- **取值离散大的字段**
  - 变量各个取值之间的差异程度的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
- **索引字段越小越好**
  - 数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
- **唯一、不为空、经常被查询的字段 的字段适合建索引**
  - 应该经常用于查询的字段创建索引，但要避免添加不必要的字段。
  - 在经常需要搜索的列上，可以加快搜索的速度；
  - 在经常使用在where子句中的列上面创建索引，加快条件的判断速度。
  - 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
- **不要使用索引的情况**
  - 避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。
  - 数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。
  - 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。
  - 在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建立用逻辑索引
  - 与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- **避免where子句中对字段施加函数，这会造成无法命中索引**

- **删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗**
- **在使用limit offset查询缓存时，可以借助索引来提高性能。**

**详细：**

​		函数，运算，否定操作符，连接条件，多个单列索引，最左前缀原则，范围查询，不会包含有NULL值的列，like 语句不要在列上使用函数和进行运算

**1）不要在列上使用函数，这将导致索引失效而进行全表扫描。**

```mysql
select * from news where year(publish_time) < 2017
```

为了使用索引，防止执行全表扫描，可以进行改造。

```mysql
select * from news where publish_time < '2017-01-01'
```

还有一个建议，不要在列上进行运算，这也将导致索引失效而进行全表扫描。

```mysql
select * from news where id / 100 = 1
```

为了使用索引，防止执行全表扫描，可以进行改造。

```mysql
select * from news where id = 1 * 100
```

**2）尽量避免使用 != 或 not in或 <> 等否定操作符**
应该尽量避免在 where 子句中使用 != 或 not in 或 <> 操作符，因为这几个操作符都会导致索引失效而进行全表扫描。尽量避免使用 or 来连接条件
应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描。

```mysql
select * from news where id = 1 or id = 2
```

**3）多个单列索引并不是最佳选择**
MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。
假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：

```mysql
select * from news where news_year = 2017 and news_month = 1
```

事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。

**4）复合索引的最左前缀原则**
复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。
假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL 语句可以写成：

```mysql
select * from news where news_month = 1
```

此时，无法使用 news_year_month_idx(news_year, news_month) 索引，因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引是不会被使用的。

**5）覆盖索引的好处**
如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。

**6）范围查询对多列查询的影响**
查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。
举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：

```mysql
select * from news where publish_time >= '2017-01-02' and publish_time <= '2017-01-08' and enable = 1
```

这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。
对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。
例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：

```mysql
select * from news where news_weekth = 1 and enable = 1
```

然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。

**7）索引不会包含有NULL值的列**
只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。
因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。

**8）隐式转换的影响**
当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。下面的案例中，date_str 是字符串，然而匹配的是整数类型，从而发生隐式转换。

```mysql
select * from news where date_str = 201701
```

因此，要谨记隐式转换的危害，时刻注意通过同类型进行比较。
**9）like 语句的索引失效问题**
like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。

#### (4) 为什么不对表总的每一列创建一个索引

- 当对表中的数据进行增加、删除和修改的时候，**索引也要动态的维护**，这样就降低了数据的维护速度。
- **索引需要占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。
- **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加

#### (5) 索引是越多越好吗

索引并非越多越好，一个表中如有大量的索引，不仅占用磁盘空间，还会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的数据更改时，索引也会进行调整和更新。

### 5. 创建索引就一定会走索引吗

​		不一定。比如，在使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。

​		举例，假设在id、name、age字段上已经成功建立了一个名为MultiIdx的组合索引。索引行中按id、name、age的顺序存放，索引可以搜索id、id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀，那么MySQL不能使用局部索引，如（age）或者（name,age）组合则不能使用该索引查询。

#### 如何判断数据库的索引有生效

可以使用**EXPLAIN语句**查看索引是否正在使用。

- possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
- key行是MySQL实际选用的索引。

如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。

#### 避免索引失效的方式

可以采用以下几种方式，来避免索引失效：

1. 使用组合索引时，需要遵循“最左前缀”原则；
2. 不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描；
3. 尽量使用覆盖索引（之访问索引列的查询），减少 select * 覆盖索引能减少回表次数；
4. MySQL在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描；
5. LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描的操作；
6. 字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）；
7. 少用or，用它来连接时会索引失效。

### 6. 索引的实现原理

在MySQL中，索引是在存储引擎层实现的，不同存储引擎对索引的实现方式是不同的，下面我们探讨一下MyISAM和InnoDB两个存储引擎的索引实现方式。

**MyISAM索引实现：**

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，MyISAM索引的原理图如下。这里假设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

<img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789725389/332A88579D961235BBA548E9EAEE0B00" alt="img" style="zoom: 25%;" />

如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示。同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

<img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789739784/B38F9D0E1D757590CB37813D1B1EE82C" alt="img" style="zoom:25%;" />

**InnoDB索引实现：**

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

下图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

<img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789752516/B2CFBBA0EA07A90332FBF75A53AFE281" alt="img" style="zoom:25%;" />

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。下图为定义在Col3上的一个辅助索引。这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

<img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789767646/42DB3CCAD12A3D1B7AC82CC8FB495C37" alt="img" style="zoom:25%;" />

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

### 7. 数据库索引的重构过程

#### 什么时候需要重建索引呢？

1. 表上频繁发生update,delete操作；
2. 表上发生了alter table ..move操作（move操作导致了rowid变化）。

#### 怎么判断索引是否应该重建？

1. 一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析：

   ```mysql
   analyze index index_name validate structure;
   ```

2. 在相同的session中查询index_stats表：

   ```mysql
   select height,DEL_LF_ROWS/LF_ROWS from index_stats;
   ```

   当查询的height>=4（索引的深度，即从根到叶节点的高度）或DEL_LF_ROWS/LF_ROWS>0.2的情况下，就应该考虑重建该索引。

#### 如何重建索引？

- drop原索引，然后再创建索引：

  ```mysql
  drop index index_name; create index index_name on table_name (index_column);
  ```

  这种方式相当耗时，一般不建议使用。

- 直接重建索引：

  ```mysql
  alter index indexname rebuild; alter index indexname rebuild online;
  ```

  此方法较快，建议使用。

rebuild是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建新索引的方法。如果重建索引时有其他用户在对这个表操作，尽量使用带online参数来最大限度的减少索引重建时将会出现的任何加锁问题。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用来将一个索引移到新的表空间。

rebuild重建索引的过程：

1. Rebuild以index fast full scan或table full scan方式（采用那种方式取决于cost）读取原索引中的数据来构建一个新的索引，重建过程中有排序操作，rebuild online执行表扫描获取数据，重建过程中有排序的操作；
2. Rebuild会阻塞DML操作，rebuild online不会阻塞DML操作；
3. rebuild online时系统会产生一个SYS_JOURNAL_xxx的IOT类型的系统临时日志表，所有rebuild online时索引的变化都记录在这个表中，当新的索引创建完成后，把这个表的记录维护到新的索引中去，然后drop掉旧的索引，rebuild online就完成了。

重建索引过程中的注意事项：

1. 执行rebuild操作时，需要检查表空间是否足够；
2. 虽然说rebuild online操作允许DML操作，但还是建议在业务不繁忙时间段进行；
3. Rebuild操作会产生大量Redo Log；

### 8. 联合索引

#### 联合索引的存储结构

从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合。

<img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789800716/95A7D1ABE86D3F34F99DEB6C1A4FD5A8" alt="img" style="zoom:33%;" />



#### 什么是联合索引

联合索引是指对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合。

<img src="https://uploadfiles.nowcoder.com/images/20220225/4107856_1645789818059/FB83705250DAD763F56B4D4E2D108F8E" alt="img" style="zoom:33%;" />

### 9. 索引的使用

#### (1) select in语句如何使用索引

索引是否起作用，主要取决于字段类型：

- 如果字段类型为字符串，需要给in查询中的数值与字符串值都需要添加引号，索引才能起作用。
- 如果字段类型为int，则in查询中的值不需要添加引号，索引也会起作用。

IN的字段，在联合索引中，按以上方法，也会起作用。

#### (2) 模糊查询语句如何使用索引

​		在MySQL中模糊查询 mobile like ‘%8765’，这种情况是不能使用 mobile 上的索引的，那么如果需要根据手机号码后四位进行模糊查询，可以用一下方法进行改造。

​		我们可以加入冗余列（MySQL5.7之后加入了虚拟列，使用虚拟列更合适，思路相同），比如 mobile_reverse，内部存储为 mobile 的倒叙文本，如 mobile为17312345678，那么 mobile_reverse 存储 87654321371，为 mobile_reverse 列建立索引，查询中使用语句 mobile_reverse like reverse(’%5678’) 即可。

​		reverse 是 MySQL 中的反转函数，这条语句相当于 mobile_reverse like ‘8765%’ ，这种语句是可以使用索引的。

## 4 MySQL事务

### 1. 什么是MySQL中的事务

​		**事务是一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。** 

​		在MySQL中，**事务是在引擎层实现的**，只有使用innodb引擎的数据库或表才支持事务。

​		MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务，MySQL原生的MyISAM引擎就不支持事务，这是被InnoDB取代的重要原因之一。

​		事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。

### 2. 事务四大特性

- **原子性**(Atomicity)
  - 原子性指的就是MySQL中的包含事务的操作**要么全部成功、要么全部失败回滚**，若成功就必须全应用到数据库，若操作失败则不能对数据库有任何影响。
- **一致性**(Consistency) 
  - 一致性指的是一个事务在**执行前后其状态一致**。
  - 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏，写入的资料必须完全符合所有的预设规则。
- **持久性**(Durability)
  - 持久性指的是**一旦事务提交，那么发生的改变就是永久性的**，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。
  - 事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的**高可靠性，而不是高可用性**。
- **隔离性**(Isolation)
  - 隔离性需要重点说一下，当多个事务同时进行时，就有可能出现 **脏读**、**不可重复读**、**幻读**的情况，**为了解决这些并发问题，提出了隔离性的概念**。
  - 要求每个读写事务的对象与其他事务的操作对象能相互分离，即该**事务提交前对其他事务都不可见**，这通常使用**锁**来实现。
  - 防止多个事务并发执行时由于交叉执行而导致数据的不一致。

####  (1) 数据库如何保证一致性？

分为两个层面来说。 

- **从数据库层面**，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。**数据库必须要实现AID三大特性，才有可能实现一致性**。例如，原子性无法保证，显然一致性也无法保证。
- **从应用层面**，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！

#### (2) 数据库如何保证原子性？

​		主要是利用 Innodb 的**undo log**。 **undo log**名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。 例如当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据

​		**undo log**记录了这些回滚需要的信息，当事务执行失败或调用了**rollback**，便可以利用**undo log**中的信息将数据回滚到修改之前的样子。

#### (3) 数据库如何保证持久性？

​		主要是利用Innodb的**redo log**。重写日志， 正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？

- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用**redo log**解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在**redo log**中记录这次操作。

​		当事务提交的时候，会将**redo log**日志进行刷盘(**redo log**一部分在内存中，一部分在磁盘上)。

​		当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据**undo log**和**binlog**内容决定回滚数据还是提交数据。

**采用redo log的好处？**

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

### 3. 数据库并发事务带来的问题

数据库并发会带来脏读、幻读、丢弃更改、不可重复读这四个常见问题。

- **脏读**
  - 事务A读取了事务B更新后的数据，但是事务B没有提交，然后事务B执行回滚操作，那么事务A读到的数据就是脏数据
- **幻读**
  - 事务A将数据库中所有学生的成绩由A->B，此时事务B手动插入了一条成绩为A的记录，在事务A更改完毕后，发现还有一条记录没有修改，那么这种情况就叫做出现了幻读。
  - 同样的条件, 第1次和第2次读出来的记录数不一样 
- **丢弃修改**
  - 两个写事务T1 T2同时对A=0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖
- **不可重复读**
  - 事务A进行多次读取操作，事务B在事务A多次读取的过程中执行更新操作并提交，提交后事务A读到的数据不一致。
  - 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了

#### 不可重复读和幻读区别

​		不可重复读的重点是修改，幻读的重点在于新增或者删除。

#### 解决可重复读和幻读问题

MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了**行锁**，并且不允许读取已提交的数据，所以**解决了不可重复读的问题**。另外，该算法包含了**间隙锁**，会锁定一个范围，因此也**解决了幻读的问题**。

### 4. SQL的隔离级别

- **未提交读**
  - 读未提交指的是一个**事务在提交之前**，它所做的修改就能够被其他事务所看到。 
  - 可能会导致**脏读、幻读或不可重复读**
  - 事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.
- **提交读**
  - 读已提交指的是一个**事务在提交之后**，它所做的变更才能够让其他事务看到。
  - **可以阻止脏读，但是幻读或不可重复读仍有可能发生**
  - 对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；
- **重复读**
  - 可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。
  - **可以阻止脏读和不可重复读，但幻读仍有可能发生**
  - 就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；
- **可串行化读**
  - 对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
  - **该级别可以防止脏读、不可重复读以及幻读**
  - 在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；

<img src="C:\Users\zyy\AppData\Roaming\Typora\typora-user-images\image-20220324172018356.png" alt="image-20220324172018356" style="zoom:50%;" />

​		其中隔离级别由低到高是：读未提交 < 读已提交 < 可重复读 < 串行化

​		隔离级别越高，越能够保证数据的完整性和一致性，但是对并发的性能影响越大。大多数数据库的默认级别是**读已提交，**比如Sql Server. Oracle，但是MySQL的默认隔离级别**可重复读**。MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ**（可重读），已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别

​		因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）并不会有任何性能损失**。

​		InnoDB 存储引擎在分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。

#### MySQL事务隔离级别的实现

1. READ UNCOMMITTED **未提交读**& READ COMMITTED **提交读**：

   ​		通过**Record Lock算法实现了行锁**，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。

2. REPEATABLE READ **可重读**：

   ​		使用**Next-Key Lock算法实现了行锁**，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。

3. SERIALIZABLE **可串行化** ：

   ​		对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。

### 5. 为什么要有事务回滚机制

​		而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。 当事务已经被提交之后，就无法再次回滚了。

**回滚日志作用：**

​		1. 能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息

​		2. 在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。

#### MySQL事务如何回滚

在MySQL默认的配置下，事务都是自动提交和回滚的。**当显示地开启一个事务时，可以使用ROLLBACK语句进行回滚**。该语句有两种用法：

- ROLLBACK：要使用这个语句的最简形式，只需发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。
- ROLLBACK TO [SAVEPOINT] identifier ：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。

### 6. 事务的类型

​		对于MySQL的InnoDB存储引擎来说，它支持**扁平事务、带有保存点的扁平事务、链事务、分布式事务**。对于嵌套事务，MySQL数据库并不是原生的，因此对于有并行事务需求的用户来说MySQL就无能为力了，但是用户可以通过带有保存点的事务来模拟串行的嵌套事务。

事务可以分为以下几种类型：

- **扁平事务**
  - 是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。
- **带有保存点的扁平事务**
  - 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。
- **链事务**
  - 可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。
- **嵌套事务**
  - 是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。
- **分布式事务**
  - 通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效。

#### 事务可以嵌套吗

​		可以，因为嵌套事务也是众多事务分类中的一种，它是一个层次结构框架。有一个顶层事务控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，它控制每一个局部的变换。

​		需要注意的是，MySQL数据库不支持嵌套事务。

## 5 MySQL锁

### 1. 悲观锁和乐观锁

​		**悲观锁，先获取锁，再进行业务操作**，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。
当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

​		**乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过**。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。

​		并发控制的主要采⽤的技术⼿段：乐观锁、悲观锁和时间戳。

### 2. 表锁和行锁

**表锁**

不会出现死锁，发生锁冲突几率高，并发低。

​		MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。

​		MySQL的表级锁有两种模式：**表共享读锁**和**表独占写锁**。

读锁会阻塞写，写锁会阻塞读和写

- 对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。
- 对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。

MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。

**行锁**

​		会出现死锁，发生锁冲突几率低，并发高。

​		在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的**行锁是通过索引加载的**，也就是说，行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。

**行锁的实现需要注意：**

- 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。
- 两个事务不能锁同一个索引。
- insert，delete，update在事务中都会自动默认加上排它锁。

#### InnoDB中行级锁的实现

​		InnoDB行级锁是通过给索引上的索引项加锁来实现的。只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

​		当表中锁定其中的某几行时，不同的事务可以使用不同的索引锁定不同的行。另外，不论使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁。

**Innodb使⽤表锁还是⾏锁？**

对于innodb，绝⼤部分情况应该使⽤⾏锁 

使⽤表锁的情况

（1）表⽐较⼤，事务需要更新全部或者⼤部分数据

（2）事务涉及到多个表，⽐较复杂，可能引起死锁，造成⼤ᰁ的事务回滚

### 3. 锁的介绍

锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。下面我们以MySQL数据库的InnoDB引擎为例，来说明锁的一些特点。



#### 锁的类型：

InnoDB存储引擎实现了如下两种标准的行级锁：

- 共享锁（S Lock），允许事务读一行数据。
- 排他锁（X Lock），允许事务删除或更新一行数据。

从数据库系统⻆度分为三种：排他锁、共享锁、更新锁。

从程序员⻆度分为两种：⼀种是悲观锁，⼀种乐观锁。

#### 锁的粒度：

​		InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为**意向锁**。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

​		InnoDB存储引擎支持意向锁设计比较简练，意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：

- 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。
- 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。

  ​	由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。

#### 锁的算法：

InnoDB存储引擎有3种行锁的算法，其分别是：

- **Record Lock：**
  - 单个行记录上的锁。
  - 总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。
- **Gap Lock：**
  - **间隙锁**，锁定一个范围，但不包含记录本身。
  - 它的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。
- **Next-Key Lock∶**
  - Gap Lock+Record Lock，**锁定一个范围，并且锁定记录本身。**
  - 结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。采用Next-Key Lock的锁定技术称为Next-Key Locking，其设计的目的是为了解决Phantom Problem（幻读）。而利用这种锁定技术，锁定的不是单个值，而是一个范围，是谓词锁（predict lock）的一种改进。
  - 采用Next-Key Lock的锁定技术称为Next-Key Locking，其设计的目的是为了解决Phantom Problem（幻读）。
  - 而利用这种锁定技术，锁定的不是单个值，而是一个范围，是**谓词锁**（predict lock）的一种改进。

#### 锁的升级：

​		锁升级（Lock Escalation）是指将当前锁的粒度降低。举例来说，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。

​		InnoDB存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。

### 4. 死锁

​		死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。下图演示了死锁的一种经典的情况，即A等待B、B等待A，这种死锁问题被称为AB-BA死锁。

#### 死锁的解决办法

​		解决死锁问题最简单的一种方法是**超时**，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。

​		除了超时机制，当前数据库还都普遍采用**wait-for graph（等待图）**的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用的这种方式。wait-for graph要求数据库保存以下两种信息：

- 锁的信息链表；

- 事务等待链表；

  ​	通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。这是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。

### 5. MVCC多版本的并发控制协议

InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。

InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：

1. 隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。
2. 基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。
3. ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。

## 6 优化

### 1. 说一说对数据库优化的理解

​		MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。例如，通过优化文件系统，提高磁盘I\O的读写速度；通过优化操作系统调度策略，提高MySQL在高负荷情况下的负载能力；优化表结构、索引、查询语句等使查询响应更快。选择正确的存储引擎

​		针对**查询**，我们可以通过使用索引、使用连接代替子查询的方式来提高查询速度。

​		针对**慢查询**，我们可以通过分析慢查询日志，来发现引起慢查询的原因，从而有针对性的进行优化。

​		针对**插入**，我们可以通过禁用索引、禁用检查等方式来提高插入速度，在插入之后再启用索引和检查。

​		针对**数据库结构**，我们可以通过将字段很多的表拆分成多张表、增加中间表、增加冗余字段等方式进行优化。

#### (1) 查询优化

**使用索引：**

​		如果查询时没有使用索引，查询语句将扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。如果使用索引进行查询，查询语句可以根据索引快速定位到待查询记录，从而减少查询的记录数，达到提高查询速度的目的。

​		索引可以提高查询的速度，但并不是使用带有索引的字段查询时索引都会起作用。有几种特殊情况，在这些情况下有可能使用带有索引的字段查询时索引并没有起作用。

1. 使用LIKE关键字的查询语句

   在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。

2. 使用多列索引的查询语句

   MySQL可以为多个字段创建索引。一个索引可以包括16个字段。对于多列索引，只有查询条件中使用了这些字段中的第1个字段时索引才会被使用。

3. 使用OR关键字的查询语句

   查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。

**优化子查询：**

​		使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。

​		子查询虽然可以使查询语句很灵活，但执行效率不高。执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。因此，子查询的速度会受到一定的影响。如果查询的数据量比较大，这种影响就会随之增大。

​		在MySQL中，**可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引，性能会更好。**

#### (2) 慢查询优化

**开启慢查询日志：**

​		MySQL中慢查询日志默认是关闭的，可以通过配置文件my.ini或者my.cnf中的log-slow-queries选项打开，也可以在MySQL服务启动的时候使用--log-slow-queries[=file_name]启动慢查询日志。

​		启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。

**分析慢查询日志：**

直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。

**常见慢查询优化：**

1. 索引没起作用的情况

   - 在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。
   - MySQL可以为多个字段创建索引。一个索引可以包括16个字段。对于多列索引，只有查询条件中使用了这些字段中的第1个字段时索引才会被使用。
   - 查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。

2. 优化数据库结构

   - 对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。
   - 对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。

3. 分解关联查询

   很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效。

4. 优化LIMIT分页

   当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。

#### (3) 插入优化

影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。针对这些情况，可以分别进行优化。

对于MyISAM引擎的表，常见的优化方法如下：

1. 禁用索引

   对于非空表，插入记录时，MySQL会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入记录的速度。为了解决这种情况，可以在插入记录之前禁用索引，数据插入完毕后再开启索引。对于空表批量导入数据，则不需要进行此操作，因为MyISAM引擎的表是在导入数据之后才建立索引的。

2. 禁用唯一性检查

   插入数据时，MySQL会对插入的记录进行唯一性校验。这种唯一性校验也会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕后再开启。

3. 使用批量插入

   插入多条记录时，可以使用一条INSERT语句插入一条记录，也可以使用一条INSERT语句插入多条记录。使用一条INSERT语句插入多条记录的情形如下，而这种方式的插入速度更快。

   ```mysql
   INSERT INTO fruits VALUES ('x1', '101', 'mongo2', '5.7'), ('x2', '101', 'mongo3', '5.7'), ('x3', '101', 'mongo4', '5.7');
   ```

4. 使用LOAD DATA INFILE批量导入

   当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句快。

对于InnoDB引擎的表，常见的优化方法如下：

1. 禁用唯一性检查

   插入数据之前执行set unique_checks=0来禁止对唯一索引的检查，数据导入完成之后再运行set unique_checks=1。这个和MyISAM引擎的使用方法一样。

2. 禁用外键检查

   插入数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。

3. 禁用自动提交

   插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。

#### (4) 数据库结构优化

- **范式优化**： 比如消除冗余（节省空间。。）
- **反范式优化**：比如适当加冗余等（减少join）
- **限定数据的范围**： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。
- **读/写分离**： 经典的数据库拆分方案，主库负责写，从库负责读；
- **拆分表**：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。

#### (5) 表优化

**在建表之初就需要考虑拆分逻辑** 

**字段优化：**

 	1. 尽量使⽤TINYINT，SMALLINT，MEDIUM_INT替代INT类型，如果是⾮负则加上UNSIGNED 

		2. VARCHAR的⻓度只分配真正需要的空间 
  		3. 尽量使⽤整数或者枚举替代字符串类型 

		4. 时间类型尽量使⽤TIMESTAMP⽽⾮DATETIME 
  		5. 单表不要放太多字段 

6. 尽量少使⽤NULL，很难查询优化⽽且占⽤额外索引空间

### 2. 谈谈SQL优化的经验

​		查询语句无论是使用哪种判断条件等于、小于、大于，**WHERE**左侧的条件查询字段不要使用函数或者表达式

​		使用**EXPLAIN**命令优化你的SELECT查询，对于复杂、效率低的sql语句，我们通常是使用explain sql来分析这条sql语句，这样方便我们分析，进行优化。

​		当你的SELECT查询语句只需要使用一条记录时，要使用**LIMIT 1**

​		不要直接使用**SELECT *** ，而应该使用具体需要查询的表字段，因为使用EXPLAIN进行分析时，SELECT*使用的是全表扫描，也就是type = all

​		为每一张表设置一个ID属性

​		避免在**WHERE**字句中对字段进行**NULL**判断

​		避免在**WHERE**中使用**！=**或 **<>** 操作符

​		使用 **BETWEEN AND** 替代 **IN**

​		为搜索字段创建索引

​		选择正确的存储引擎，InnoDB、MylSAM、MEMORY等

​		使用**LIKE %abc%**不会走索引，而使用**LIKE abc%**会走索引

​		对于枚举类型的字段（即有固定罗列值的字段），建议使用**ENUM**而不是**VARCHAR**，如性别、星期、类型、类别等

​		拆分大的**DELETE**或**INSERT**语句、

​		选择合适的字段类型，选择标准是尽可能小、尽可能定长、尽可能使用整数。

​		字段设计尽可能使用NOT NULL

​		进行水平切割或者垂直分割

​				水平分割：通过建立结构相同的几张表分别存储数据
​				垂直分割：将经常一起使用的字段放在一个单独的表中，分割后的表记录之间是一一对应关系。

### 3. 假如你MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？

- 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
- 选择合适的表字段数据类型和存储引擎，适当的添加索引。
- MySQL库主从读写分离。
- 找规律分表，减少单表中的数据量提高查询速度。
- 添加缓存机制，比如Memcached，Apc等。
- 不经常改动的页面，生成静态页面。
- 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。

### 4. 表中包含几千万条数据该怎么办？

建议按照如下顺序进行优化：

1. 优化SQL和索引；
2. 增加缓存，如memcached、redis；
3. 读写分离，可以采用主从复制，也可以采用主主复制；
4. 使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的；
5. 做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；
6. 做水平拆分，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。

### 5. 数据库高并发的解决方案吗

- 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。
- 增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）
- 主从读写分离，让主服务器负责写，从服务器负责读。
- 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。
- 使用分布式架构，分散计算压力。

### 6.MySQL主从同步是如何实现的？

复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理分为以下3个步骤：

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。
3. 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。

复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示，其中从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。



# Redis

